 \input ctustyle
 \input glosdata
 \input opmac-bib
 \worktype [B/CZ]
 \faculty {F3}
 \department {Katedra řídicí techniky}
 \title {Řízení bezkartáčových motorů s deskou Raspberry Pi a Linuxem}
 \author {Martin Prudek}
 \date {Květen, 2015}
 \supervisor {Ing. Pavel Píša, Ph.D.}
 \studyinfo  {Studiní program: Kybernetika a robotika.
 
 
 Obor: Systémy a řízení.}  % Study programme etc.
 
 
 \specification {\picw=16.6cm \cinspic zadani.pdf }
 
 
 \abstractEN {Bachelor thesis is focused on control of permanent magnet synchronous motors (PMSM) with single-board computer Raspberry Pi and Linux. For this purpose expansion unit which integrates power management and field-programmable gate array (FPFA) is used.
 
 The first part of thesis deals with theory of PMSM, including their construction, mathematical description and possibilities of control. After this, presentation of used hardware, Raspberry Pi, expansion unit and motor takes place.
 
 Thesis continues with description of operating system GNU/Linux and its Real-Time modification.
 
 To fulfil communication between expansion unit and superior system protocol SPI is used. Its implementation in FPGA and Raspberry Pi is described in next chapter.
 
 For the purpose of measure currents in stator windings is used solution which takes advantage of Hall effect. Voltages, that are obtained this way are then processed with A/D converter. To read values from A/D converter simple communication protocol is implemented in FPGA.    
 
 The last part of the thesis examines multiple possibilities of electronic commutation. Commutation that utilizes only outcome of Hall effect sensors and simple commutation that carry out phase shift by $120^\circ$ are implemented. In the very end the vector control of PMSM is presented.
    }
 
 \abstractCZ {Bakalářská práce se zabývá řízením bezkartáčových synchronních motorů (PMSM) s~deskou Raspberry Pi a Linuxem. K~tomuto účelu je použita rozšiřující jednotka integrující část pro výkonové řízení a programovatelné hradlové pole (FPGA). 
 
 V~první části práce je popsána problematika PMS motorů, včetně jejich matematického popisu, konstrukce a možností řízení. Následuje seznámení s~použitým technickým vybavením, Raspberry Pi, rozšiřující jednotkou a motorem. 
 
 Práce pokračuje popisem operačního systému GNU/Linux a jeho Real-Time modifikací. 
 
 Pro komunikaci mezi rozšiřující jednotkou a nadřazeným sytémem je použit protokol SPI. Jeho  implementace v~rámci FPGA obvodu a Raspberry Pi je věnována další kapitola.
 
 Měření proudů protekajích fázemi vinutí je řešeno s~využítím Hallova efektu. Takto získaná napětí jsou zpracována AD převodníkem. Ke čtení hodnot z~AD převodníků je v~FPGA obvodu navržen jednoduchý komunikační protokol. 
 
 Poslední část práce se zabývá různými možnostmi elektronické komutace. Implementována je komutace využívající pouze výstupu z~Hallových sond a jednoduchá komutace realizující posun fází o~$120^\circ$. V~samotném závěru je uvedena možnost vektorového řízení.
 }
\keywordsEN {%
   brushless; permanent magnet motor; bachelor thesis; FPGA; Raspberry Pi; Linux; Real-Time; control; PMSM.
}
\keywordsCZ {%
  synchronní bezkartáčový motor; bakalářská práce; FPGA; Raspberry Pi; Linux; Real-Time; řízení; PMSM.
}
\thanks {           % Use main language here
   Na tomto místě bych chtěl především velmi poděkovat svému vedoucímu bakalářské práce, panu Ing. Pavlu Píšovi, PhD. za vstřícnost, ochotu a trpělivost. Bez jeho cenných rad a zkušeností by tato práce nemohla vniknout. 
} 
 
 \declaration {Prohlašuji, že jsem předloženou práci vypracoval samostatně a že jsem uvedl veškeré použité informační zdroje v~souladu s~Metodickým pokynem o~dodržování etických principů při přípravě vysokoškolských závěrečných prací.
 
    V~Praze dne  
   \signature % makes dots
}
 \makefront

 
 \def\frac#1#2{{\begingroup#1\endgroup\over#2}} %/frac je LaTex, definujme vlastni

 \chap Úvod
 
  Elektrické motory jsou již dlouhou dobu nedílnou součástí moderní civilizace. Jejich řízení se stalo důležitou disciplínou, potřebnou v~mnoha aplikacích. Postupem času se přitom stává výhodnějším i pro menší výkony použít složitější elektroniku než řešit komutaci mechanickými kartáči. 
  
  Synchronní bezkartáčový motor přitom nabízí ve srovnáním s~konvenčním  DC motorem několik výhod. Nedochází k takovému opotřebení mechanických částí, ani ke kolísání točivého momentu v průběhu otáčky. Zvyšuje se efektivita. Více o~PMS motorech je uvedeno v~kapitole \ref[chap_pmsm].
  
  Cílem práce je především výuka řízení a možnost experimentování. Pro tyto účely má smysl pro řízení použít kompletní systém typu Linuxového stroje i tam, kde se produkční provedení realizují malými MCU. Do takto rozsáhlého systému je možné snadno integrovat i další funkce právě například pro výuku nebo další rozšíření. Výhodou je také pohodlný vzdálený přístup přes SSH nebo HTTP, který malé MCU ve velké míře neumožňují.

Na trhu je dnes celá řada malých jednodeskových počítačů, které nedosahují kvalit potřebných pro průmyslové nasazení. Je ale možné je využít k návrhu řízení a komunikace s výkonovou částí. Takto vytvořená řešení jsou pak použitelná i při nasazení na profesionálnějších systémech.
  
   Z široké nabídky takových zařízení, jako jsou BeagleBone, Raspberry Pi či Banana Pi  
 \fnote{Root.cz, Srovnání: Raspberry Pi a jeho největší konkurenti \url{http://www.root.cz/clanky/srovnani-raspberry-pi-a-jeho-nejvetsi-konkurenti/}} 
 bylo vybráno pro tuto práci Raspberry PI model B rev. 2.0. 
 
 {\bf Raspberry Pi} (dále také \uv{RPi}) je počítač realizovaný na jednom plošném spoji, velikosti kreditní karty, který od roku 2006 vyvíjí britská nadace {\em Raspberry Pi Foundation} \fnote{web Raspberry Pi Foundation\url{https://www.raspberrypi.org/}}. Výhodou je možnost využití univerzálního operačního systému, například výrobcem připraveného sestavení operačního systému GNU/Linux na bázi distribuce Debian. Na takto upravený systém, pojmenovaný Raspbian, je pak možné aplikovat Real-Time modifikaci, která zajistí splnění požadavků řídicí aplikace. Více k~Raspberry Pi a RT modifikaci Linuxu uvedu v~sekci \ref[sec_rpi] a \ref[sec_rt].
 
 U~tohoto počítače již byla prostudována možnost řízení stejnosměrného motoru s~využitím softwarového zpracování impulzů inkrementálního rotačního senzoru polohy \cite[Meciar]. Pro použitý, nepříliš výkonný, hardware však softwarové dekódování impulzů představuje pro vyšší rychlosti otáčení motoru takovou zátěž, kterou již není schopen operační systém bezchybně obsloužit. U~RPi tak docházelo ke kritickým časovým prodlevám při zpracovávání přijatých pulsů, čímž se ztrácela informace o~poloze. Takové chování nastávalo již od frekvence pulsů 14kHz, což při 500 pulsech na jednu otočku dělá 2100ot/min. Tedy ve chvíli, kdy perioda příchodu pulsů byla srovnatelná s~dobou odezvy systému na tento druh události.
 
 Výhodným řeším tohoto problému se stává přesunutí zpracování pulsů \glref{IRC} do samostatné periferie a zjištěnou polohu motoru posílat v binární podobě. RPi tedy zpracovává jen jednu řídicí smyčku o~neměnné frekvenci. Z~hlediska výpočetního výkonu tedy již otáčky motoru nehrají roli. Protože RPi nedisponuje periferíí vhodnou pro tento účel, byla pro tuto práci použita rozšiřující deska vyvinutá firmou {\em PiKRON} \fnote{PiKRON \url{http://www.pikron.com/}}. Tato deska umožňuje návrh potřebné logiky v~\glref{FPGA} obvodu. Podrobnosti v~sekci \ref[sec_fpga].
 
 Pro propojení rozšiřující desky a nadřazeného systému (RPi) bylo třeba vybrat jednoduchý komunikační protokol. Požadavkem byla možnost obousměrné komunikace a dostatečná rychlost, která umožní pro  požadovanou frekvenci řídicí smyčky přenést dostatečný objem dat. Bylo také nutné, aby použitý protokol byl, pokud možno, jednoduše realizovatelný v~FPGA obvodu a zároveň ho bylo možné pohodlně zpracovat v~jádře operačního systému na RPi. Více o výběru a implementaci komunikačního protokolu v sekci \ref[kom_prot_sec].
 
 Bylo otestováno jednoduché řízení podle kombinace Hallových senzorů popsané v sekci \ref[hall_only_sec]. Napěťové řízení se sinusovým průběhem v sekci \ref[120_sec] a jednoduché vektorové řízení v sekci \ref[vektor_impl_sec].


 
 \label[chap_pmsm]
 \chap PMS motory

PMS (Permanent Magnet Synchronous) motory jsou díky vysoké efektivitě a robustní kontrukci bez kartáčů vhodnou volbou v~mnoha řídicích aplikacích\cite[ESD]. Zvláště pak v~robotice a všude tak, kde je zapotřebí řízení polohy a rychlosti.

Na rozdíl od kartáčových motorů je komutace PMS motorů řízena elektronicky, což přínáší vyšší požadavky na řídicí hardware. Ve chvíli, kdy dnes většina aplikací vyžaduje elektronické řízení jak rychlosti, tak točivého momentu, nepředstavuje ale řídicí elektronika zátěž navíc. \cite[sensorless]. Odměnou je naopak výšší výkon v~poměru k~váze, stejně tak točivý moment v~poměru k~příkonu. Výhodou jsou také nížší hlučnost a delší životnost, protože nedochází k~opotřebení kartáčů a mechanických částí komutátoru. \cite[PMSM-Kinetis] Elektronická komutace bývá implementována v~procesorovém systému, či speciálním obvodu (FPGA / ASIC)\cite[Meloun].
 
 3-fázové synchronní motory s~permanentním magnetem se často využívají kromě PMS varianty se sinusovým průběhem \glref{BEMF} také v~\glref{BLDC} variantě s~lichoběžníkovým (trapezoidal) průběhem BEMF. Přičemž výhodou PMSM je konstatní točivý moment v~celém rozsahu otáčení, zatímco BLCD motor je snadněji řiditelný a dnes se již využívá převážně z~historických  důvodů. \cite[sensorless]
 \sec Konstrukce
 
 Základ konstrukce PMS Motoru tvoří rotor s~permanentním magnetem a stator, kterým prochází vinutí jednotlivých fází. 
 
 Počet vinutí pak závisí na počtu pólů permanentního magnetu umístěného ve statoru. Obvyklá varianta jsou dva páry pólů (polpáry) permanentního magnetu, viz Obrázek \ref[pole_pairs]. Celý návrh je přitom optimalizován pro buzení sinusovým průběhem, stejně tak zpětné  elktromotorické napětí vykazuje sinusový průběh. \cite[ijetae] \cite[ti_pmsm].
 
\medskip \clabel[pole_pairs]{PMS Motor se dvěma pólovými dvojicemi}
\picw=7cm \cinspic PMSM.png
\caption/f PMS Motor se dvěma pólovými dvojicemi
\medskip 


 \sec Matematický popis
 
 Pro matematický popis dějů v~PMS motorech a vláště pak pro implementaci plného momentového řízení jsou vhodným nástrojem Clarkova a Parkova tranformace. Ty jsou využity k vytvoření modelu použitého třífázového motoru (točivého elektrického stroje) který je uveden dále v této sekci.
 
 \secc Clarkova transformace
 
 Clarkova transformace umožňuje zobrazit proud protékající jednotlivými fázemi jako jeden vektor v~komplexní rovině.
 
 Uvažujme $i_{a}$, $i_{b}$ a $i_{c}$ proudy procházející vinutím statoru, platí:
 
 $$\label[soucet_nula_rce] i_{a} + i_{b} + i_{c} =0\eqmark $$
 
 Toto může být vyjádřeno jako vektor v~komplexní rovině, potom:
 
 $$
 \label[s_operatory_rce] 
 \overline{i} = i_{a}+\hat{a}i_{b}+\hat{a}^2i_{c} \eqmark$$
 
 kde $\hat{a}$ a $\hat{a}^2$ jsou operátory posouvající fáze o~$\delta=120^{\circ}={2\pi\over3}rad$. Operátory mají podobu: $ \hat{a}=e^{j\delta} $ a $\hat{a}^2=e^{2j\delta}$. 

\medskip \clabel[proudy]{Komplexní vyjádření vektoru proudu vinutím statoru}
\picw=6cm \cinspic currents.pdf
\caption/f Komplexní vyjádření vektoru proudu vinutím statoru (Clarkova transformace) v $\alpha\beta$ souřadné soustavě. $\alpha$ je reálná a $\beta$ imaginární osa.
\medskip %obrazek zustal tam, kde ma. \midinsert ho posunul 
 
 Po dosazení za $\hat{a}$ je možné rovnici \ref[s_operatory_rce] přepsat:
 $$ 
 \overline{i} = i_{a}+i_{b}e^{j\delta}+i_{c}e^{2j\delta} \eqmark$$
  Použijeme-li Eulerův vzorec $e^{j\phi}=\cos{\phi} + j\sin{\phi}$ a Moivreovu větu $(\cos{x}+j\sin{x})^n=\cos{(nx)}+j\sin{(nx)}$, dostáváme ekvivalentní vyjádření pomocí goniometrických funkcí:
 $$ \label[rce_cplx]\overline{i} = i_{a}+i_{b}(\cos{\delta}+j\sin{\delta})+i_{c}(\cos{2\delta}+j\sin{2\delta}) \eqmark
 $$
 $\overline{i}$ lze interpretovat jako součet jeho reálné a imaginární složky v soustavě $\alpha\beta$:

 $$
  \overline{i}=i_{\alpha}+ji_{\beta} 
  \eqmark$$
 
 Z~rovnice \ref[rce_cplx] je pak možné vyjádřit reálnou a imaginární složku $\overline{i}$ a zapsat maticové vyjádření Clarkovy transformace:
 $$
 \label[clark_matrix_rce]
  \left[\matrix{i_{\alpha} \cr
                i_{\beta} \cr
    }\right]
    =
  \left[\matrix{1&\cos{\delta}&\cos{2\delta} \cr
                0&\sin{\delta}&\sin{2\delta} \cr
    }\right]
     \left[\matrix{i_{a} \cr
                i_{b} \cr
                i_{c}
    }\right]
    \eqmark$$
Po dosazení za $\delta=120^{\circ}$ do rovnice \ref[clark_matrix_rce] dostáváme:
 $$
  \left[\matrix{i_{\alpha} \cr
                i_{\beta} \cr
    }\right]
    =
  \left[\matrix{1&-{1\over2}&-{1\over2} \cr
                0&{\sqrt{3}\over2}&-{\sqrt{3}\over2} \cr
    }\right]
     \left[\matrix{i_{a} \cr
                i_{b} \cr
                i_{c}
    }\right]
    \eqmark$$
 

Pro popis PMS motorů je uvažován ideálně symetrický motor se sinusoidně rozloženým vinutím. Pro takovou idealizaci uvažujeme napětí na vinutích $u_{a}$, $u_{b}$ a $u_{c}$  následující:

$$
\label[rce1]
u_{a}=R_si_{a}+{{d}\over{dt}}\psi_{a} \eqmark$$
$$ u_{b}=R_si_{b}+{{d}\over{dt}}\psi_{b} \eqmark$$
$$
\label[clark_napet_rce_3]
u_{c}=R_si_{c}+{{d}\over{dt}}\psi_{c} \eqmark$$

kde $\psi_{a}$,$\psi_{b}$ a $\psi_{c}$ jsou magnetické indukční toky vyvolané proudy odpovídajících vinutí. Vyjádření složek napětí v $\alpha\beta$ souřadné soustavě odpovídá:

 $$ u_{\alpha}=R_si_{\alpha}+{{d}\over{dt}}\psi_{\alpha} \eqmark$$
 $$ u_{\beta}=R_si_{\beta}+{{d}\over{dt}}\psi_{\beta} \eqmark$$
 
 Přitom složky magnetického indukčního toku statoru budou:
 
 $$\psi_{\alpha} = L_{\alpha}i_{\alpha} + \psi_Mcos\theta \eqmark$$
 $$\psi_{\beta} = L_{\beta}i_{\beta} + \psi_Msin\theta \eqmark$$
 
 kde $\theta$ je úhlová pozice rotoru a $\psi_M$ je magnetický indukční tok rotoru. $L_{\alpha}$ a $L_{\beta}$ jsou složky vzájemné indukčnosti rotor-stator.  

Úhlové zrychlení takového motoru s momentem setrvačnosti $J$ o~zátěži $M_L$ s~$p$ póly připadajícími na každou fázi můžeme vyjádřit jako:

$$
\label[rce2]
{d\omega\over{dt}}=
{1\over{J}}\lbrack{3\over{2}}p(\psi_{\alpha}i_{\beta}-\psi_{\beta}i_{\alpha})-M_L\rbrack
\eqmark
$$

Rovnice \ref[rce1] az \ref[rce2] představují model PMS motoru v~souřadné soustavě $\alpha\beta$, ktérá je fixována statorem \cite[PMSMC].

\secc Parkova transformace

Kromě soustavy spojené se statorem bývá někdy výhodné vyjádřit proudy a další veličiny v~soustavě spojené s~rotorem. Pro dosažení maximálních momentových účinků, je totiž nutné, aby vektor megnetické indukce, magnetického pole vyvolávaného proudy protékající vinutím statoru, svíral pravý úhel s~vektorem mg. indukce mg. pole permanentního magnetu rotoru. 

Pro tyto účely je tedy vhodné veličiny fixovat k~osám spojeným právě s~rotorem. Osy jsou nazývané {\em d} a {\em q} a jejich poloha je ilustrována na obrázku \ref[dq0]. 

V~soustavě spojené se statorem byly veličiny s~úspěchem vyjádřeny pomocí Clarkovy transformace. K~jejich vyjádření v~soustavě rotující společně s~rotorem, je silným nástrojem transformace Parkova (dq0 transformace).

Transformace je realizována podobně, jako v~předchozím případě, pomocí operátoru otočení. Symbol $\overline{i}_{r} $ představuje komplexní vektor proudu vztažený k~osám {\em d} a {\em q}.

$$
\label[park_1_rce] 
\overline{i}_r=\overline{i}e^{-j\theta} \eqmark$$ 

Kde $\theta$ je úhlová pozice rotoru, viz obrázek \ref[dq0].

 \medskip \clabel[dq0]{Poloha os Parkovy transformace}
\picw=8cm \cinspic dq0.pdf
\caption/f Osy d(direct) a q(quadrature) jsou voleny vzhledem k~rotoru.
\medskip 

Vztah \ref[park_1_rce] je možné podobně jako rovnicí \ref[s_operatory_rce] přepsat pomocí Eulerova vzorce do následujícího tvaru:
$$ \label[park_cplx_rce] 
\overline{i}_r=\overline{i}(\cos{\theta} - j\sin{\theta})
 \eqmark$$ 
 
Složky komplexního vektoru $\overline{i}_r$ v {\em dq0} sostavě souřadné pak můžeme po dosazení z výrazu \ref[rce_cplx] zapsat jako: 
 
$$ \label[park_rce] 
\overline{i}_r=i_d+ji_q=(i_{\alpha} + ji_{\beta})(\cos{\theta} - j\sin{\theta})
 \eqmark$$ 

  Pomocí rovnice \ref[park_cplx_rce] je možné vyjádřit také maticový tvar Parkovy transformace:
  $$
  \label[rce_park]
  \left[\matrix{i_{d} \cr
                i_{q} 
    }\right]
    =
  \left[\matrix{\cos{\theta}&\sin{\theta} \cr
                -\sin{\theta}&\cos{\theta} 
    }\right]
     \left[\matrix{i_{\alpha} \cr
                i_{\beta} 
    }\right]
    \eqmark
    $$

Složky napětí v {\em dqo} souřadném systému jsou následující:
$$u_{d}=R_si_{d}+{d\over{dt}}\psi_{d}-\omega\psi_{q} \eqmark $$
$$u_{q}=R_si_{q}+{d\over{dt}}\psi_{q}-\omega\psi_{d} \eqmark $$

 Symbol $\omega$ je úhlová rychlost rotoru. $\psi_d$ a $\psi_q$ jsou složky magnetického indukčního toku statoru vyjádřeného v~{\em dq0} souřadném systému. 

Jednotlivé složky je možné vyjádřit: 

 $$\label[psi_d_rce] \psi_{d} = L_{d}i_{d} + \psi_M \eqmark$$
 $$\label[psi_q_rce] \psi_{q} = L_{q}i_{q} \eqmark$$
 
\medskip \clabel[park]{Parkova transformace}
\picw=8cm \cinspic StatorCurrents.pdf
\caption/f Parkova transformace 
\medskip 
 
Úhlové zrychlení motoru s momentem setrvačnosti $J$ o~zátěži $M_L$ s~$p$ póly připadajícími na každou fázi můžeme v v~{\em dq0} souřadném systému vyjádřit jako\cite[PMSMC]: 

$$
\label[rce3]
{d\omega\over{dt}}=
{1\over{J}}\lbrack{3\over{2}}p(\psi_{d}i_{q}-\psi_{q}i_{d})-M_L\rbrack
\eqmark
$$
 

Po dosazení za $\psi_d$ a $\psi_q$ z rovnic \ref[psi_d_rce] a \ref[psi_q_rce] do \ref[rce3] dostáváme:


$$
{d\omega\over{dt}}=
{1\over{J}}\lbrack{3\over{2}}p(\psi_Mi_q+(L_d-L_q)i_{q}i_{d})-M_L\rbrack
\eqmark
$$

Točivý moment $M$ motoru tak vypadá následovně:

$$
M={3\over{2}}p(\psi_Mi_q+(L_d-L_q)i_{q}i_{d})
\eqmark
$$

Za předpokladu $i_{d}=0$, pak dojde ke zjednodušení:
$$
\label[ctrl_rce]
M={3\over{2}}p\psi_Mi_q
\eqmark
$$
Z rovnice \ref[ctrl_rce] vyplývá, že točivý moment motoru je možné libovoně řídit, jen nastavením hodnoty $i_q$ \cite[torque_ctrl] \cite[nlin_torq_ctrl]. Procesem, jak z $i_q$ vypočítat proudy jednotlivými fázemi se zabývá sekce \ref[rizeni_sec]. Implementace možného řešení je v sekci \ref[vektor_impl_sec].


\label[rizeni_sec]
 \sec Řízení
 
 PMS Motory se vyznačují plynulou rychlostí v~celém rozsahu otáčení a schopností plně řídit točivý moment i při nulové rychlosti. K~tomu se využívaji techniky vektorového řízení. 
 
 S jejich pomocí je možné rozložit proud protékající vinutím statoru na složky generující magnetické pole a točivý moment. Tyto složky pak můžeme řídit na sobě nezávisle a přiblížit se tak v jednoduchosti řízení standartního kartáčového DC motoru \cite[PMSMC]. 
 
  V~této práci je implementovávo poziční řízení s možností rozšíření na plné momentové řízení. Z rovnice \ref[ctrl_rce] vyplývá, že pro poziční a momentové řízení je nutné modifikovat pouze složku $i_q$ komplexního vektoru proudu $\overline{i}$.

 Matematickým nástrojem, jak přepočítat $i_q$ na statorové proudy $i_a$, $i_b$ a $i_c$ jsou inverzní Parkova a Clarkova transformace, kterým je věnován zbytek této sekce. Implementace možného řešení je popsána v sekci \ref[vektor_impl_sec]. Pro názornost jsou zde obě transformace uváděny v~maticovém tvaru.
  \secc Inverzní Parkova transformace
  
    Maticový tvar dopředné Parkovy transformace je uveden v~rovnici \ref[rce_park]. Transformační matice je regulární a je tedy možné jednoduše vytvořit její inverzi:
   $$
   \label[inv_clark_rce]
  \left[\matrix{i_{\alpha} \cr
                i_{\beta} 
    }\right]
    =
  \left[\matrix{\cos{\theta}&-\sin{\theta} \cr
                \sin{\theta}&\cos{\theta} 
    }\right]
     \left[\matrix{i_{d} \cr
                i_{q} 
    }\right]
    \eqmark
    $$
    
    V~případě, že je úhel odečítán opačným směrem, než je v~matematice obvyklé (obvyklý směr je proti chodu hodinových ručiček), je možné do rovnic dosadit $\theta=-\vartheta$. 
  $$
   \label[inv_clark_rce_2]
  \left[\matrix{i_{\alpha} \cr
                i_{\beta} 
    }\right]
    =
  \left[\matrix{\cos{\vartheta}&\sin{\vartheta} \cr
                -\sin{\vartheta}&\cos{\vartheta} 
    }\right]
     \left[\matrix{i_{d} \cr
                i_{q} 
    }\right]
    \eqmark
    $$    
    
    Tento případ se týká i řešení použitého v~této práci.
 

    
 \secc Inverzní Clarkova transformace
 
Nyní jsou již k~dispozici hodnoty $i_{\alpha}$ a $i_{\beta}$, k~jejich přepočtení na jednotlivé fáze slouží inverzní Clarkova transformace.  

Vytvořit inverzi k~transformační matici v~rovnici \ref[clark_matrix_rce] není možné. Je tedy nutné rozšířit transformaci o~osu $\gamma$. Proud v~této ose označme $i_{\gamma}$ a definujme $i_{\gamma}=z( i_{a} + i_{b} + i_{c})$.
 $$
  \left[\matrix{i_{\alpha} \cr
                i_{\beta} \cr
                i_{\gamma}
    }\right]
    =
  k\left[\matrix{1&\cos{\delta}&\cos{2\delta} \cr
                0&\sin{\delta}&\sin{2\delta} \cr
                z&z&z
    }\right]
     \left[\matrix{i_{a} \cr
                i_{b} \cr
                i_{c}
    }\right]
    \eqmark
    $$
    
Tímto způsobem byla transformační matice rozšířenana velikost 3x3. Matice je pro $z\not=0$ a $k\not=0$ regulární, je tak možné vytvořit matici inverzní a celé inverzní zobrazení.
 $$
   \left[\matrix{i_{a} \cr
                i_{b} \cr
                i_{c}
    }\right]
    =
  {{2}\over{3k}}\left[\matrix{1&0&{2\over{z}} \cr
                \cos{\delta}&\sin{\delta}&{2\over{z}}\cr
                \cos{2\delta}&\sin{2\delta}&{2\over{z}}
    }\right]
  \left[\matrix{i_{\alpha} \cr
                i_{\beta} \cr
                i_{\gamma}
    }\right]
    \eqmark 
    $$
    
 Pokud je transformační konstanta rovna $k={2\over{3}}$, nedochází k~zesílení požadovaných proudů. Konstanta $z$ bývá z~estetických důvodů volena $z={1\over2}$. Po dosazení do takto zvolených konstant  vyčíslení $\delta=120^{\circ}={2\pi\over3}rad$, bude rovnice vypadat:
   $$
   \label[inv_clark_num_rce]
   \left[\matrix{i_{a} \cr
                i_{b} \cr
                i_{c}
    }\right]
    =
  \left[\matrix{1&0&1 \cr
                -{1\over2}&{\sqrt{3}\over2}&1\cr
                -{1\over2}&{-\sqrt{3}\over2}&1
    }\right]
  \left[\matrix{i_{\alpha} \cr
                i_{\beta} \cr
                i_{\gamma}
    }\right]
    \eqmark 
    $$
    
 Zde je nutné připomenout, že z~rovnice \ref[soucet_nula_rce] vyplývá:  $i_{\gamma}=z( i_{a} + i_{b} + i_{c}) = 0 $.
 
 \secc Transformace napětí při delta zapojení
 
 S využitím inverzní Clarkovy transformace lze vypočítat jednotlivé statorové proudy. Z rovnic \ref[rce1] až \ref[clark_napet_rce_3] pak vyplývá, že proudy je možné řídit napětím na vinutí. 
 
 Nyní je tedy třeba  napětí $u_a$, $u_b$ a $u_c$, které představují akční zásahy pro řízení proudů, přepočítat na napětí $u_1$, $u_2$ a $u_3$, která jsou již přímo úměrná šířce plnění PWM. Pro výpočet je uvažováno zapojení typu \uv{delta}, které je použito i při konstrukci použitého motoru, viz. sekce \ref[motor_sec]. Schématicky problém postihuje obrázek \ref[delta_obr]. 
 
 \medskip \clabel[delta_obr]{Delta zapojení}
\picw=10cm \cinspic delta.pdf
\caption/f Delta zapojení 
\medskip 

Pro vyjádření napětí $u_a$, $u_b$ a $u_c$ je možné využít následující vztahy:
$$
\eqalignno{
    u_a &=u_3-u_2 & \eqmark \cr 
	u_b &=u_2-u_1 & \eqmark \cr 
	u_c &=u_1-u_3 
 & \eqmark \cr}
 $$
Maticový zápis:
 $$
  \left[\matrix{u_{a} \cr
                u_{b} \cr
                u_{c}
    }\right]
    =
  \left[\matrix{0&-1&1 \cr
                -1&1&0 \cr
                1&0&-1
    }\right]
     \left[\matrix{u_{1} \cr
                u_{2} \cr
                u_{3}
    }\right]
    \eqmark
    $$
Soustava je přeurčená, matice sostavy je tedy singulární a není možné vytvořit inverzní matici. Při parametrizaci jednoho z napětí, vyberme $u_{3}=t$, je ale možné vyjádřit $u_1$ až $u_3$, tak, aby jejich rozdíly (napětí $u_a$ až $u_c$) zůstaly zachovány:
$$
\eqalignno{
	\label[u1_rce] u_1 &=t+u_c & \eqmark \cr 
	u_2 &=t+u_c+u_b & \eqmark \cr 
	\label[u3_rce] u_3 &=t 
 & \eqmark \cr}
 $$
Parametr $t$ je možné volit libovolně. Implemetací se zabývá sekce \ref[vektor_impl_sec].

   
 
 \chap Popis hardware
 
 Minulá kapitola shrnula teorii týkající se konstrukce bezkartáčových motorů a jejich řízení. Nyní bude následovat bude popis konkrétního technického vybavení použitého pro tuto práci. 
 
 Budou tak popsány parametry použitého motoru a Raspberry Pi. Prostor bude věnován problematice OS Linux a jeho Real-Time modifikaci. Následně dojde na téma FPGA obvod a jeho naprogramování. Kapitola je ukončena sekcí o rozšiřující jednotce, která integruje všechny tyto komponenty do jedoho řešení.
 
 \label[motor_sec]
 \sec Použitý motor
 
 Z~široké nabídky bezkartáčových PMS motorů byl vybrán model BLWR233D-36V-4000 od společnosti Aneheim Automation \fnote{Aneheim Automation BLWR23 \url{http://www.anaheimautomation.com/products/brushless/brushless-motor-item.php?sID=148&pt=i&tID=96&cID=22}} viz. Obrázek \ref[motor_obr]. Jedná se o~motor s~výkonem 92W, pracující při maximálním napětí 36V. Vinutí statoru tvoří 6 polpárů  Vinutí každé z~fází tedy tvoří právě dvě pólové dvojice. Analogicky má stator motoru právě dva polpáry, viz. Obrázek \ref[pole_pairs].
 
\medskip \clabel[motor_obr]{Použitý motor}
\picw=8cm \cinspic motor.png
\caption/f Použitý motor 
\medskip  
 
  V~motoru jsou integrovány Hallovy sondy, které snímají absolutní polohu motoru ve 12 úsecích mechanického plného úhlu. Při přechodu mezi dvěma úseky se mění práve jeden z~výstupních signálů těchto senzorů. V~místech přechodu je tedy možné určit pozici motoru relativně přesně.
  
   Do motoru je přivedeno celkem 8 vodičů ve dvou svazcích. Ve svazku o~třech vodičích jsou přivedeny fáze, v~ostatních je pak napájení a výstup Hallových senzorů, viz. Tabulka \ref[vodice_tab]. V~Tabulce \ref[motor_tab] jsou pak uvedeny technické parametry motoru.

 \medskip \clabel[motor_tab]{Parametry použitého motoru}
\ctable{lll}{ 
	\hfil Veličina & Uvedené hodnoty / jednotky & Metrický systém  \crl
		Max. napětí & 36 V~& 36 V~\cr
		Max. výkon & 92 W & 92 W  \cr
		Max. točivý moment & 31.2 oz-in & 0.0219 Nm  \cr
		Max. otáčky & 4000 rpm & 4000 rpm   \cr
		Torque constant & 8.5 oz-in/A & 0.06 Nm/A  \cr
		BEMF konst. & 4.45 V/krpm  & 4.45 V/krpm   \cr
		Odpor mezi fázemi (line-to-line)& 0.64 $\Omega$ & 0.64 $\Omega$   \cr
		Vzájemná indukčnost fází & 2.1 mH & 2.1 mH    \cr
		Moment setrvačnosti rotoru & 0.00106 oz-in-$sec^2$ & $7.485*10^{-6}$ kg$*m^2$  \cr
		Délka & 2.9 in & 73.7 mm   \cr
		Váha & 1.65 lbs & 0.75 kg  \cr	
}
\caption/t Parametry použitého motoru 
\medskip

 \medskip \clabel[vodice_tab]{Vodiče přivedené do motoru}
\ctable{lll}{ 
	\hfil Svazek & Barva & Funkce  \crl
		1 & Žlutá & Fáze A~\cr
		1 & Červená & Fáze B  \cr
		1 & Černá & Fáze C  \cr
		2 & Červená & Napájení hallů  \cr
		2 & Modrá & Hall senzor A~\cr
		2 & Zelená & Hall senzor B  \cr
		2 & Bílá & Hall senzor C  \cr
		2 & Černá & Uzemění hallů  \cr
}
\caption/t Vodiče přivedené do motoru 
\medskip 
  
  K~motoru je též z~jedné strany namontován inkrementální rotační čítač (dále jen \glref{IRC}), který měří přírůstky polohy motoru vůči pozici při startu řízení. Jeho výhodou je vysoká přesnost.  Zatímco Hallovy sondy dokáží rozlišit jen mezi 12 polohami na jednu mechanickou otáčku, použitý IRC rozezná 2000 samostatných pozic (běžné hodnoty rozlišení tohoto typu senzorů se pohybují v~rozmezí 16 až 10000 bodů na otáčku). K~IRC vedou vodiče napájení a signálů s~daty o~poloze. Dva z~nich jsou signály, které ze svých aktuálních stavů a jejich změn poskytují informaci o~pohybu motoru a jeho směru. Třetí signál pak vyšle puls vždy jen v~jedné pozici za jednu mechanickou otáčku motoru. Poskytuje tak absolutní polohu.
  
 

 
 \label[sec_rpi]
 \sec Raspberry Pi
 
 Raspberry Pi je jednodeskový počítač založený na rodině architektury ARM, který se v~současnosti dodavá v~několika variantách.
 
 Základem první verze tohoto minipočítače je \glref{SoC} BCM2835, který obsahuje centrální procesor ARM1176JZF-S s~taktem 700 MHz, grafický procesor VideoCore IV a 256 MB nebo 512 MB  paměti RAM. Neumožňuje však příme připojení pevného disku pomocí SATA a neobsahuje ani jinou trvalou integrovanou velkokapacitní paměť (MTD). Operační systém a data, která mají být uchována i po restartu zařízení je tak třeba uložit na SD kartu, jejíž slot je k~dispozici.
 
  Procesorová jednotka typu ARM11 využíva poměrně zastaralou architekturu ARMv6 se statší verzí jednotky pro výpočty v plovoucí řádové čárce \glref{VFP}v2 \cite[ARM11] \fnote{ARM11 Online Technical Reference Manual \url{http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0301h/Cegdejjh.html}},která již není podporovaná sestavením systému Debian pro moderní zařízení s procesorem ARM. Proto je nutná rekompilace distribuce systému Debian/Raspbian. Oficiální port této distribuce ARMhf totiž vyžaduje alespoň architektutu ARMv7 s~koprocesorem pro výpočty v~plovoucí řádové čárce nejméně ve verzi VFPv3-D16. \fnote{Debian, List of official ports \url{https://www.debian.org/ports/}}
 
\medskip \clabel[RPiB+]{Raspberry Pi v1 model B+}
\picw=8cm \cinspic Raspberry_Pi_B+_top.png
\caption/f Raspberry Pi verze 1 model B+
\medskip 
 
Druhá verze Raspberry Pi přinesla zvýšení výpočetního výkonu s~růstem taktu procesoru na 900Mhz a využitím čtyř výpočetních jader. To vše pod modernější architekturou ARMv7-A s~procesorem ARM Cortex-A7 (podpora \glref{VFP}v4 \cite[CA_VFP] \fnote{ARM Cortex-A7 Online Technical Reference Manual \url{http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.subset.cortexa.cortexa7/index.html}}) v~čipu BCM2836. Tato verze počítače je tak se současnými distribucemi plně kompatibilní. Kromě vyššího výpočetního výkonu došlo i k~nárustu hlavní paměti na 1GB. Momentálně je k~dispozici jen v~modelu B, který navazuje na model B+ verze 1. Na rozdíly jednotlivých variant odkazuje tabulka \ref[RPi_Modely]

Nevýhodou použitých SoC v~obou verzích je chybějící integrovaná podpora rozhraní ethernet. Pro připojení do sítě toho typu je použit na desku integrovaný převodník USB-Ethernet.  

%clabel prida referenci - muzu odkazovat \ref + prida do seznamu tabulek / obrazku
%midinsert, topinsert - chce na zacatek stranky, kdyz to nejde, prejde na zacatek dalsi
\midinsert \clabel[RPi_Modely]{Seznam modelů Raspberry Pi}
\ctable{lccccc}{ 
	\hfil Model & A~& A+ & B & B+ & Bv2 \crl
		Počet pinů & 26 & 40 & 26 & 40 & 40  \cr
		RAM paměť [MB]  & 256 & 256 & 256/512 & 512 & 1024   \cr
		USB porty & 1 & 1 & 2 & 4  & 4 \cr
		RJ45 & Ne & Ne & Ano & Ano  & Ano \cr
		Slot na kartu & SDHC & MicroSD & SD & MicroSD & MicroSD   \cr
		Příkon [W] & 1.5 & 1.0 & 3.5 & 3 & 4  \cr
		Takt CPU [MHz] & 700 & 700 & 700 & 700 & 900  \cr
		Jádra CPU [MHz] & 1 & 1 & 1 & 1 & 4  \cr
		CPU Arch [W] & ARMv6 & ARMv6 & ARMv6 & ARMv6 & ARMv7-A  \cr
}
\caption/t Seznam modelů Raspberry Pi 
\endinsert


 \label[sec_rt]
 \sec Jádro Linux a jeho použitelnost pro RT aplikace
 
 Linux je víceuživatelský, víceúhlový operační systém založený na stejnojmenném jádře, které vyvinul v~roce 1991 Linus Thorvadls. Po aplikaci úprav pro zaručení kontrolovaného času odezvy na vnější události (RT-rozšíření) se stává zajímavou volbou i pro některé řídicí aplikace.
 
 Systém, který byl původně myšlen spíše jako koníček se postupem času vyvinul z~pouhého emulátoru terminálu v~jeden z~nejpoužívanějších na světě. Dnes mají Linuxové distribuce 97\% zastoupení mezi největšími superpočítači \fnote{Linux dominates supercomputers \url{http://www.zdnet.com/article/linux-dominates-supercomputers\|-as-never-before}} a například systém Android, s~Linuxovým jádrem, běží na 47\% všech smartphonů a tabletů \fnote{Mobile/Tablet Operating System Market Share \url{http://marketshare.hitslink.com/operating\|-system-market-share.aspx?qprid=8&qptimeframe=M&qpcustomd=1}}. Mohutný rozmach systému byl zapříčiněn mimo jiné zveřejněním jeho zdrojového kódu pod svobodnou licencí. To umožnilo na jeho vývoji pracovat tisícům dobrovolníků a mnoha korporacím, mezi které patří například Red Head, Intel, Samsung či Google \fnote{Who actually develops Linux? \url{http://www.extremetech.com/computing/175919-who-actually-\|develops-linux-the-answer-might-surprise-you}}.
 
 
 Pro široké možnosti svého využití a jednoduché vzdálené správy si systém brzy získal oblibu mezi vyvojáři. Doménou řídicích aplikací však dále zůstavaly menší systémy. Linux se tak stával součástí jen větších celků, kde za odezvu k~kritických částech byl zodpovědný \glref{RT} OS a Linux plnil spíše administrativní funkce. Vývoj plikací pro menší RT OS však přinaší mnoho komplikací navíc, přikladem je spíše minimalistické \glref{API} a často nedostatečná podpora některých komunikačních protokolů. Vznikl tak projekt, jehož cílem bylo upravit linuxové jadro způsobem, který umožní včasné přeplánování a zajistí tak splnění časových požadavků vyžadovaných řízením. 
 
 Projekt KURT (Kansas University Real Time) se stal průkopníkem, když využil podporu Linuxu pro víceprocesorové systémy (\glref{SMP}) a rozšířil možnost souběhu procesů při zpracování systémových volání v~jádře, což jádro dříve v~plné míře nedovolovalo. Serializace takových úseků, ve kterých se v~danou chvíli směl nacházet jen jeden procesor je pak řešena zámky s~aktivním čekáním (spin-lock). Ostatní úseky kódu s~nutností vyloučení vzájemného  souběhu namísto spin-locků začaly využívat RT-mutex. Další snaha byla minimalizovat či přepracovat části kódu, které neumožňují preempci, jako například obslužné rutiny přerušení. Důležitá je implementace dědění priorit. \cite[rychlost_odezvy]  \cite[preemption] 
 
 Vzhledem k~rozsáhlosti zdrojového kódu systému Linux není možné analyticky spočítat veškerá zpoždění a vyhodnotit tak maximální latenci systému a časy potřebné k~přeplánování. Podobný výpočet by navíc nebyl možný při použití rozmanitých vyrovnávacích pamětí a víceprocesorových systémů. Pro mnoho aplikací je však dostačující znát průběhy zpoždění měřeného na zatíženém systému v~delším časovém období - řádově v~měsících. Těmito testy a také dalším vývojem RT vlastností Linuxu se zabývá laboratoř OSADL \fnote{OSADL \url{http://www.osadl.org/}}. 
 
 Jedna z~posledních verzí RT-varianty jádra (3.18.7-rt2), tak po měsících testování reakcí na vnější události nevykázala byť jediné zpoždění přesahující 100$\mu$s. Přičemž testy probíhaly  na výkonném HW s~architekturou x86. Pro některé další architektury, napřiklad ARM pak zpožnějí pro vybrané modely nepřesahuje 200$\mu$s. \cite[rychlost_odezvy].
 

 \label[sec_fpga] 
 \sec FPGA obvod 
 
FPGA obvody (Field Programmable Gate Array - Programovatelná hradlová pole) jsou speciální číslicové integrované obvody obsahující různě složité programovatelné bloky, dále násobičky či různé druhy pamětí. Tyto bloky jsou propojené konfigurovatelnou maticí spojů. FPGA obvody se odlišují od naprosté většiny integrovaných obvodů možností přeprogramování - při změně požadavků lze jednoduše náhrát novou konfiguraci.

FPGA se v~současnosti využívají v~mnoha aplikacích. Těží tak svých vlastností, mezi které patří poměrně snadný návrh v~některém z~HDL jazyků či grafických nástrojů. Flexibilita, neustále klesající cena ale i zmenšující se spotřeba elektrické energie patří mezi další pozitiva. Jsou tak zajímavou alternativou pro návrh a výrobu integrovaného obvodu na míru, jehož zavedení do výroby bývá velmi nákladné s~návratností při výrobě miliónů kusů. Další běžnou oblastí použití je prototypování složitějších zařízení či tvorba periferií pro procesorové jednotky - tzv. \uv{Glue logic}. Složitější FPGA obvody je dokonce možné použít k~implementaci procesoru.\cite[fpga_proc]  \cite[xilinx_fpga] \cite[bart_dis]

Pro tuto práci byl vybrán FPGA obvod od společnosti {\em Microsemi Corporation} \fnote{Microsemi Corporation \url{http://www.microsemi.com/}} z~rodiny IGLOO. Konkrétně čip AGL125 v~pouzdře VQ100. Tato jednotka obsahuje 125 tisíc hradel a nabízí mimo jiné 36 kbits RAM. Podporuje In System Programming (\glref{ISP}) a lze naprogramovat prostřednictvím rozhraní \glref{JTAG} \cite[AGL125]. 

Na rozdíl od větších a výkonnějších obvodů Xilinx a Altera zde dochází k~uložení konfigurace přímo do obvodu a není ji tak třeba nahrávat z~externí FLASH či z~CPU. Taktéž poměr ceny a kvality produktu je příznivý. Pro inicializaci hodnot v~obvodu při zapnutí napájení pak může být využit externí signál. Výhodným řešením může být i využití resetu z~bloku fázového závěsu (PLL), které je implementováno i v této práci. Bez implementace tohoto mechanismu je ale třeba brát na zřetel hrozbu inicicializace na nevhodné hodnoty. Přikládem jsou signály pro ovládání polovičních H-můstků, které, při inicializaci na logickou jedničku mohou zapříčinit přehřátí a zničení motoru.  

Návrh byl vytvořen v~HDL jazyce VHDL. Jazyk VHLD slouží jak k~popisu a následné syntéze obvodu v~programovatelném hradlovém poli, tak k~simulacím. Používá se také pro popis obvodů, které se podle návrhu ve VHDL později přímo vyrobí.  Standardizován byl v~r. 1987. Jako jazyk vyvinutý z~přísně typového jazyka Ada si pak ponechává některé jeho vlastnosti, které se s~výhodou využijí při popisu hardware. 

Mezi tyto výhody patří zabudovaná možnost souběžného výkonávání kódu. Tato funkce se totiž plně využije právě při navrhování hardware, kde je souběžné vykonávání elementární záležitostí. Vznikají tak bloky {\em Process}, které po příchodu spouštěcího signálu pracují zcela paralelně. 

\sec Syntéza VHDL kódu a programování FPGA

Pro syntézu kódu je používán balíček aplikací {\em Libero} viz. Manuál \cite[Libero_ug] vyvíjený výrobcem obvodu. Program je možné používat i zdrama. Jedinou podmínkou je registrace a získání \uv{FREE Licence}. Před každým spuštěním aplikace pak musí běžet licenční daemon. Jeho spouštěcí příkaz je následující:
\begtt
/opt/microsemi/licensing_daemon/lmgrd ...
-c /opt/microsemi/license/license.dat ...
-l /home/user/license.log
\endtt

Samotná syntéza je pak řízena skripty v jazyce TCL. Zvlášť je použit skript pro analýzu a syntézu logiky a skript pro vlastní umístění logiky do jednotlivých elementů obvodu programem "synplify_pro", který je součástí balíčku staženého s~aplikací Libero. Oba kroky syntézy jsou pak společně volané shellovým skriptem "synthetize-agl.sh".  Všechny soubory VHDL, včetně nejvyšší entity, musí být uvedené v~souboru "syn.tcl" a při syntéze musí být umístěné v~spolu s shellovým skriptem v~jednom adresáři.

Pro naprogramování FPGA obvodu je využívána open-source aplikace  {\em UrJTAG} hostovaná na serveru {\em Sourceforge} \fnote{UrJTAG, Sourceforge.net \url{http://sourceforge.net/projects/urjtag/}}. Pro běh aplikace je nutné mít nainstalovány knihovny "libusb" a "libftdi". Poté je  možné FPGA obvod naprogramovat spuštěním skriptu "program-agl.sh" ze stejného adresáře, ve kterém proběhla syntéza.

\label[vyk_hw_sec]
\sec Rozšiřující jednotka

Rozšiřující jednotka k~RPi je tvořena dvojicí plošných spojů vyvinutých firmou {\em PiKRON} pro účely experimentování s řízením motorů s využitím FPGA na Katedře řídicí techniky. Jsou zde integrovány bloky pro výkonové řízení motoru a měření proudů protékajících jeho vinutím. V~tomto místě také dochází ke zpracování výstupů z~IRC a Hallových senzorů. Pro ochranu řidíci elektroniky a potlačení rušení je výkonová část kompletně galvanicky oddělena od napájení RPi a FPGA obvodu pomocí dvoukanálových číslicových izolátorů \fnote{ADuM1200 Dual-Channel Digital Isolators \url{http://www.analog.com/media/en/technical-\|documentation/data-sheets/ADuM1200_1201.pdf}}.
  
Výkonové řízení motoru realizuje trojice polovičních H-můstků tvořených vždy dvojicí výkonových N-MOS trazistorů. Každá dvojice/půlmůstek je řízená integrovaným obvodem řady LT1158 \fnote{Half Bridge N-Channel Power MOSFET Driver \url{http://cds.linear.com/docs/en/datasheet/1158fb.pdf}}. Vstupy těchto budičů jsou již ovládány přímo z FPGA.

Pro měření statorových proudů, protékajících jednotlivými fázemi motoru, je použita sada senzorů využívajících Hallova efektu. K~odečítání napěťové úrovně senzorů je určen 12-bitový AD převodník \fnote{ ADS7841 \url{http://www.ti.com/lit/ds/symlink/ads7841.pdf}}. Tento integrovaný obvod je vybaven čtyřmi kanály, z~nichž zde jsou použity tři. Pro přepínání mezi nimi je v~převodníku integrován multiplexor. ADC může pracovat při napájecím napětí v~rozsahu od 2.7V do 5V. Od napájecího napětí, které je současně i referenčním (viz. Příloha \ref[priloha_motor]), se následně odvíjí frekvence hodinového signálu, kterou je obvod časován a slouží i k přenosu dat. Při $U_{ref}$=2.7V je maximální frekvence 2Mhz, pro $U_{ref}$=5 pak $f_{CLK}$=5Mhz \cite[adc_man].

 Jedná se o~převodník s~postupnou aproximací. Tento druh převodníku vyžaduje pro každý převod pevně stanovený počet hodinových cyklů. Při každém hodinovém cyklu pak teoreticky dochází k~zpřesnění o~jeden bit. Realizován bývá obvykle s~využitím několika komponent. Jednou z~nich je jednoduchý analogový vzorkovač, který udrží měřenou veličinu neměnnou po čas nutný pro konverzi. Dalšími součástmi jsou DA převodník a aproximační registr (SAR). Komunikací s~AD převodníkem se podrobně věnuji v~sekci \ref[adc_sec].
 
 

\medskip \clabel[propojeni_obr]{Propojení Raspberry Pi s~výkonovým HW}
\picw=10cm \cinspic propojeni.png
\caption/f Propojení Raspberry Pi s~výkonovým HW
\medskip 

 Celá rozšiřující jednotka může být napájena v~poměrně velkém rozsahu napětí pohybujím se mezi 9V až 30V. Toto napětí je poté konvertováno pomocí DC-DC měniče \fnote{TEN 6-2411WIN  Traco Power DC/DC Converters \url{http://mediaserver.voxtechnologies.com/FileCache/Traco\%20Power-TEN\%206WIN\%20Series-datasheet1-1243850956.pdf}} na hodnotu 5V, které je vyžadováno RPi. Protože logika na RPi využíva 3.3V napěťovou úroveň, dojde zde ještě ke konverzi na 3.3V, kterými je napájen i FPGA obvod. Mechanické propojení rozšiřující jednotky s~Raspberry Pi je realizováno prostřednictvím plochého 26-žilového kabelu viz. Obrázek \ref[propojeni_obr]. Schéma obou plošných spojů se nachází v~příloze \ref[priloha_motor].



 
 
 
 
 
 
 
 
 \chap Použité řešení
 
 V~předcházející kapitole jsem se věnoval použitému hardware a jeho specifikacím. Nyní popíši, jak probíhala práce samotná. 
 
 První sekce diskutuje volbu frekvence řídicí smyčky. Následuje debata k objemu dat, který je třeba přenášet mezi Raspberry Pi a rozšiřující jednotkou. Další sekce se zabývá výběrem a implementací vhodného komunikačního protokolu, který slouží k~propojení rozšiřující jednotky s~nadřazeným hardware. Následuje část, která se věnuje čtení a částečnému zpracování dat z~A/D převodníku. Ten je připojen k~senzorům snímajícím statorové proudy. Budou probrány požadavky RT rozšíření Linuxu a postupu pro jeho přípravu. Tématem stane i generování PWM signálů a dekódování IRC. Nakonec bude popsána elektronická komutace.
 
 \label[ctr_loop_freq]
 \sec Frekvence řídicí smyčky
 
 Ve chvíli, kdy přejdeme od spojitého řízení k~diskrétnímu, je nutné se zabývat frekvencí řídicí smyčky.
 
  Řídicí smyčka je proces, při kterém dochází k~periodickému vzorkování hodnot nutných pro řízení a následnému nastavení velikosti akčního zásahu. Její frekvence je tak závislá na časových konstantách řízeného systému, či zjednodušeně, jen na té dominantní. V~případě elektrických motorů je přitom dominantní časovou konstantou časová konstanta mechanická.
 
 U~malých elektrických motorů se mechanická časová konstanta pohybuje v~rozmezí od 1 do 20ms. Je ale obvyklé, že i moderní motory s~lehkou kotvou nemají menší hodnoty mechanické časové konstanty než 3ms. \cite[rychlost_odezvy]. Pro přesné určení časových konstant je třeba brát v~úvahu parametry motory uvedené v~manuálu nebo v~tabulce \ref[motor_tab]. V případě reálné aplikace pak i transformovanou hodnotu momentu setrvačnosti zátěže, která výslednou časovou konstantu zvyšuje.
 
 Model motoru, kde je implementováno poziční řízení má charakter integrátoru. Pokud vyžadujeme od regulátoru kvalitní výsledky, především krátkou dobu ustálení, je tak třeba volit frekvenci regulační smyčky alespoň dvojnásobnou v~porovnání s~vlastní frekvencí motoru, tedy převrácenou dominantní časovou konstantou.
 
  V~mezním případě můžeme vlastní frekvence dosahovat hodnot $f={{1}\over{0.003}}=333$Hz. S~dostatečnou rezervou tak byla zvolena frekvence regulační smyčky o~velikosti 1kHz.
 
 \sec Objem dat přenášených mezi RPi a rozšiřující jednotkou
 
 K~úspěšnému řízení potřebuje řídící jednotka (RPi) data získaná ze senzorů proudu, IRC a Hallových sond. Rozšiřující jednotka pak vyžaduje hlavně šířku plnění PWM a řídicí signály pro poloviční H-můstky. Je také nutné určit přesnost, s~jakou se budou potřebná data přenášet. 
 
 Z~IRC je posíláno 32 bitů dat s~informací o~aktuální poloze motoru. Dále je posílána 12-bitová informace o~vzdálenosti od indexu. Index je přesně určené místo v~rozsahu otáčení, maximální hodnota této vzdálenosti tak může být 1999 rozlišitelnýcch pozic. Tři byty obsazeny výstupy z~Hallových sond. Následuje 3x16 bitů informace o~změřených proudech. Celkem tak v~tomto směru dojde při každém průchodu řídicí smyčkou k~výměně 128 bitů dat.
 
 Ke výměně stejného objemu dat dojde z~důvodu použitého komunikačního protokolu i v~opačném směru. Z~RPi do rozšiřující jednotky přichází tři 11-bitové informace o~šířce plnění PWM. Tyto hodnoty jsou ale pro snadnější manipulaci zarovnány na 16 bitů. Jen dolních 11 z~nich je ale využito. Součástí přenosu jsou ještě 3 bity odemykající poloviční H-můstky a 3 bity určené k~jejich úplné deaktivaci. Poslední využitý bit pak při změně z~logické 0 do 1 povoluje resetování AD převodníku. Celkem je v~tomto směru komunikace využito jen 40 ze 128 bitů.
 
 
 \label[kom_prot_sec]
 \sec Komunikační protokol
 
 Výběr komunikačního protoku mezi RPi a FPGA obvodem se stal jednou z~prvních otázek a bylo ji třeba zodpovědět již na začátku práce. 
 
 Existuje celá řada známých a hojně využívaných protokolů pro komunikaci ať již mezi periferiemi a procesorovou jednotkou či mezi procesory navzájem. Příkladem je $I^2C$, SSI, USART a jeho synchronní varianta SPI. Požadavkem přitom bylo, aby komunikační protokol byl dostatečně rychlý a aby při frekvenci minimálně 1kHz dokázal přenést alespoň 128bitů. A~to oběma směry. Je také nutné, aby byl dostatečně jednoduchý pro efektivní realizaci v~FPGA obvodu.
 
 Protokol $I^2C$ se zdál příliš složitý, vzhledem ke svým módům. Adresace, kterou poskytuje by mohla být využita v~případě ovládání více os, je zde zbytečná. Hlavní nevýhodou je nedeterministické chování.
 
  Asynchronní verze protokolu USART nemá v~tomto případě smysl, protože náš FPGA obvod nemá vnitří zdroj hodinového signálu. Hlavní doménou tohoto protokolu je využití pro konzoli ajeho složitá implementace na straně operačního systému opět nezaručuje determinismus.
  
\midinsert \clabel[spi_obr]{SPI s~jedením uzlem typu slave}
\picw=10cm \cinspic SPI_single_slave.pdf
\caption/f SPI s~jedením uzlem typu slave (Zdroj:wikipedia.org)
\endinsert

   Jako příhodné varianty se jeví protokoly SSI a SPI. Výhodou SSI protokolu je, že jím generovaný hodinový signál, posílaný po samostatném vodiči, není zastaven s~koncem komunikačního cyklu. Protokol SPI hodinový signál v~této chvíli zastavuje a je tedy nutné do FPGA obvodu přivést hodinový signál jinou cestou. Hodinový signál je totiž nutný pro funkci všech synchronních komponent obvodu. Na rozdíl od protokolu SSI je ale SPI velmi pohodlně přístupný z uživatelské aplikace. Není tedy třeba tvořit vlastní ovladač. Výhodou SSI ale zůstává časté použití při připojování obvodů k~DSP a pro motion control. Pro práci byl nakonec vybrán protokol SPI. 

SPI je deterministický komunikační protokol využívající model komunikace \uv{master-slave}. Pro komunikaci mezi dvěma zařízeními jsou vyžadovány obvykle čtyři datové vodiče. 

\begitems

*"SCLK" přenaší hodinový signál, jehož zdrojem je zařízení typu \uv{master}. 

*"MOSI" (Master Out Slave In) je datová linka nesoucí sekvenci bitů směrem od \uv{master} ke \uv{slave}. 

*"MISO" (Master In Slave Out) pak vede data opačný směrem. 

*"SE" (Slave Enable, někdy značeno "CE" - Chip Enable, na \uv{slave} zařízeních "SS" - Slave Select), je čtvrtý vodič, obvykle řízený inverzní logikou (Active-Low), kterým master oznamuje slave, že spustí hodinový signál a dojde k~výměně dat. V~případě více uzlů typu \uv{slave} vede do každého zvláštní vodič "SE", zatímco ostatní tři jsou společné. 

\enditems

Existují čtyři módy tohoto protokolu, které lze volit nastavením dvou konfiguračních bitů \cite[spidev_sum]. 

\begitems

 *"CPOL", první bit, definuje, jaký je stav hodin (signálu "SCLK") na počátku komunikace - ve chvíli, kdy "SE" přejde do stavu "Low". Při "CPOL"=0 je počáteční stav "SCLK"=0 a první hrana je tedy nástupná. Při "CPOL"=1 začínají hodiny ve stavu "High" a první hrana je sestupná.
 
 *"CPHA", druhý bit,  indikuje, zda jsou data vzorkována či zapisována při nástupné nebo sestupné hraně. Při "CPHA"=0 jsou data vzorkována při nástupné hraně "SCLK" a zapisována při hraně sestupné. Pokud je "CPHA"=1, je tomu naopak.

\enditems
 
  Platí přitom, že zápis dat, stejně jako jejich vzorkování, probíhá v~obou zařízeních současně. Přiřazení režimů k nastavení jednotlivých bitů  shrnuje Tabulka \ref[spi_tab].
 \medskip \clabel[spi_tab]{Módy protokolu SPI}
\ctable{ccc}{ 
	\hfil Mód & CPOL & CPHA  \crl
		{\bf 0} & {\bf 0} & {\bf 0}  \cr
		1 & 0 & 1  \cr
		2 & 1 & 0  \cr
		3 & 1 & 1  \cr
}
\caption/t Módy protokolu SPI 
\medskip 

Při použití módů 0 a 2, kdy "CPHA"=0 je nutné data připravit ještě před příchodem první hrany hodin. Ta, ať už je sestupná či nástupná, totiž data již vzorkuje. Data jsou tedy vystavena s~poklesem signálu "SE". Průběhy komunikace při jednotlivých kombinacích "CPOL" a "CPHA" ukazuje Obrázek \ref[spi_mods_obr]. 

\midinsert \clabel[spi_mods_obr]{Průběh komunikace po SPI při různých módech}
\picw=9cm \cinspic SPI_timing_diagram2.pdf
\caption/f Průběh komunikace po SPI při různých módech (Zdroj:wikipedia.org)
\endinsert 

Protože jednotlivé módy jsou kvalitativně rovnocené, výběr jednoho z~nich není nijak rozhodující. Přesto se dá říci, že mód 0 je asi nejpoužívanější, proto byl zvolen právě ten. Dále v~textu nebudu tuto problematiku více zmiňovat a budu předpokládat, že používáme právě mód 0. Šířka přenášeného slova pak byla zvolena na osm bitů.  

\secc Zdroj hodinového signálu pro FPGA

Jak bylo uvedeno výše, hodinový signál generovaný při použití protokolu SPI trvá jen po dobu přenosu dat. Zdrojem hlavního hodinového signálu pro FPGA obvod se tak stal generátor hodinových pulzů na RPi, jehož výstup je možné přivést na jeden ze vstupně/výstupních pinů. Jeho frekvence byla stanovena na 50MHz. Dále v~textu bude tento signál označen stejně, jako ve VHDL kódu, tedy "gpio_clk". 

\label[spi_slave_sec]
 \secc SPI slave v~FPGA obvodu
 
 FPGA obvod je v~tomto řešení uzlem typu slave. V opačném případě by mohlo docházet k problémům se zajistěním trvalé připravenosti RPi v roli slave. Pokud je ale RPi uzlem typu master, tak se případné problémy v dostatečně rychlém plnění a čtení SPI neprojeví, protože se SPi periferie zastaví a zastaví i hodiny přenosu. Implementace obvodového návrhu se nachází souboru "rpi_pmsm_control.vhdl".
 
Komunikace je pak součástí jednoho Procesu v~jazyce VHDL. Proces byl vytvořen jako synchronní, spínaný jen nástupnou hranou vnitřního hodinového signálu ("gpio_clk"). Spínání tohoto procesu signály "SCLK" a "SE" by nebylo výhodné, protože by vedlo k~vytvoření nové hodinové domény. V takovém případě by bylo nutné řešit přenos již širokých paralelních dat mezi hodinovými doménami. Je tedy nutné signály "SE" a "SCLK" synchronně vzorkovat. V~kódu Procesu se tak objeví následující část:

\begtt
	wait until (gpio_clk'event and gpio_clk='1');		
		  --SCLK edge detection
		  spiclk_old(0)<=spi_clk;
	 	  spiclk_old(1)<=spiclk_old(0);
			
		  if (spiclk_old="01") then --rising edge, faze cteni
		  ...				
		  práce s daty		
		  ...
		  end if;
\endtt
 
 Protokol SPI je v~FPGA obvodu obvykle implementován jako posuvný registr viz. Obrázek \ref[spi_trans_obr]. 

\midinsert \clabel[spi_trans_obr]{Realizace SPI pomocí posuvného registru}
\picw=9cm \cinspic SPI_8-bit_circular_transfer.pdf
\caption/f Realizace SPI pomocí posuvného registru (Zdroj:wikipedia.org)
\endinsert 
 
 Průběh komunikace ilustruje obrázek \ref[spi_mods_obr]. S~aktivací signálu "SE", tedy s~jeho sestupnou hranou, jsou připraveny data do posuvného registru. Zároveň je třeba do vodiče "MISO" zapsat první bit přenosu. První příchozí hrana signálu "SCLK" je nástupná, tedy vzorkovací. Po jejím příchodu je posuvný registr posunut o~jeden bit doleva a na uprázdněné místo je zapsán aktuální stav vodiče "MOSI".
 
 \begtt
 dat_reg(127 downto 0) <= dat_reg(126 downto 0) & spi_mosi;
 \endtt
 
 Po příchodu druhé hrany signálu "SCLK", tedy sestupné, je nutné vystavit do vodiče "MISO" nový bit.
 
  \begtt
 spi_miso <= dat_reg(127); 
 \endtt
 

Tento postup se opakuje až do deaktivace signálu "SE".
 
 \secc SPI master na Raspberry Pi
 
 Pro uživatelské aplikace je periferie SPI v~OS Linux zpřístupněna jako znakové zařízení (obvyklé řešení pro Unix nebo Windows NT). Po otevření určeného souboru/inode reprezentujícího SPI je možné přenosy realizovat voláním řídicí funkce (systémového volání IOCTL) s~určenými parametry. Implementace znakového zařízení je umístěna v~driveru "spidev.c", který je součástí jádra OS Linux.
 
 Ve~přiloženém kódu je pak pužití tohoto driveru součástí souboru "rp_spi.c". V~úvodu je třeba vložit hlavičku "#include <linux/spi/spidev.h>". Klíčovým prvkem je zde volání zmíněné funkce "int ioctl(int d, int request, ...);". První argument, argument "d", je file descriptor znakového zařízení. Zařízení je zpřístupněno voláním funkce "int open(const char *pathname, int flags)",která vrací deskriptor. Argumentem "pathname" je cesta k~souboru. Argument "flags" určuje mód otevření. Příkaz tedy může vypadat:
 \ttline+0
 \begtt
 int fd = open("/dev/spidev0.1", O_RDWR);\endtt
 
 Makro "O_RDWR" specifikuje otevření pro čtení i psaní.
 
 Druhým argumentem funkce "int ioctl(int d, int request, ...)" je request kód. Jedná se o~kód specifický pro každou operaci s~daným zařízením zvlášť. Posledním argumentem je ukazatel (pointer) na datovou strukturu specifickou pro daný příkaz. Datový typ ukazatele není striktně určen. Konvence však, tam, kde není uvedeno jinak, doporučuje volit "char * argp" \cite[ioctl_man].
 
 Jako první je třeba nastavit mód SPI, to je provedeno s~kódem operace definovaným makrem "SPI_IOC_WR_MODE" následovně:
  \begtt
  unsigned char mode = 0;
  int ret = ioctl(fd, SPI_IOC_WR_MODE, &mode);\endtt
  
 Dále je nutné stanovit délku slova, využijeme "SPI_IOC_WR_MODE":
 \begtt
 unsigned char bits = 8;
 ret = ioctl(fd, SPI_IOC_WR_BITS_PER_WORD, &bits);\endtt
  
  Poslední část konfigurace vyžaduje nastavit frekvenci hodin "SCLK", použijeme kód operace "SPI_IOC_WR_MAX_SPEED_HZ". Frekvence je očekávána v~jednotkách Hz.:
  
   \begtt
 unsigned int speed = 500000;
 ret = ioctl(fd, SPI_IOC_WR_MAX_SPEED_HZ, &speed);\endtt
  
  Před samotným přenosem je ještě nutné nastavit parametry specifické pro daný přenos, vyplnit ukazatel na úsek paměti s výstupními daty ("tx") a ukazatel na oblast připravenou pro uložení vstupních dat ("rx").
 \ttline+7  
  \begtt
  unsigned char rx[16];
  unsigned char tx[16];\endtt
    
 Parametry jsou uloženy ve struktuře "spi_ioc_transfer":
\ttline+9 
\begtt
struct spi_ioc_transfer tr = 
{
    .tx_buf = (unsigned long)tx,
    .rx_buf = (unsigned long)rx,
    .len = 16,
    .delay_usecs = 0,
    .speed_hz = speed,
    .bits_per_word = bits,
};\endtt
 
 Přenos je spuštěn opět voláním IOCTL, s kódem operace "SPI_IOC_MESSAGE(1)". 
\begtt
ret = ioctl(fd, SPI_IOC_MESSAGE(1), &tr);\endtt

Po jeho úpěšném průběhu je možné již používat doručená data v paměti odkazované ukazatelem "rx".


\secc Pořadí dat v~přenosu
 
  Prvním přenášeným bitem komunikace je bit s~nejvyšší hodnotou (MSB), tedy bit "dat_reg(127)" na straně FPGA. Za předpokladu, že data pro přenos jsou v~Raspberry uchovávána v~poli charů a odpadnou tak problémy s~endianitou (instrukce ARMv6 jsou defaultně little-endian \fnote{ARMv6 Support for mixed-endian data \url{http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0301h/Cdfbbchb.html}}), bude prvním přenášeným bitem MS bit v~"tx[0]". Pozice a funkce bitů v~přenosech z~Raspberry Pi do FPGA a v~opačném směru jsou zdokumentované v tabulce \ref[data_order1_tab] a \ref[data_order2_tab].
  
 \medskip \clabel[data_order1_tab]{Pořadí dat v~přenosu A}
\ctable{ccc}{ 
	\hfil Bity & Byte přenosu & Funkce \crl
		127 & tx[0] &Aktivace resetu AD převodníku \cr
		126 .. 124 & tx[0] & Enable PWM1 .. PWM3 \cr
		123 .. 121 & tx[0] & Shutdown můstku pro PWM1 .. PWM3 \cr
		120 .. 43 &  &- \cr		
		42 .. 32 & tx[10] tx[11] & Šířka plnění PWM1 \cr
		31 .. 27 & &- \cr
		26 .. 16 & tx[12] tx[13] & Šířka plnění PWM1 \cr
		15 .. 11 & &- \cr		
		10 .. 0 & tx[14] tx[15] & Šířka plnění PWM1 \cr
}
\caption/t Přenos z~Raspberry Pi do FPGA obvodu 
\medskip 

 \medskip \clabel[data_order2_tab]{Pořadí dat v~přenosu B}
\ctable{ccc}{ 
	\hfil Bity & Byte přenosu & Funkce \crl
		127 ..96 & rx[0] .. rx[3] & IRC \cr
		95 & rx[4] & Hall 1 \cr
		94 & rx[4] & Hall 2 \cr
		93 & rx[4] & Hall 3 \cr
		92 .. 81 & rx[4] rx[5] & Pozice indexu\cr
		80 .. 72 & rx[5] rx[6] & Počet sečtených proudů \cr
		71 .. 48 & rx[7] .. rx[9] & Součet proudů, kanál 2 \cr
		47 .. 24 & rx[10] .. rx[12] & Součet proudů, kanál 0 \cr
		23 .. 0 & rx[13] .. rx[15] & Součet proudů, kanál 1 \cr
}
\caption/t Přenos z~FPGA obvodu do Raspberry Pi 
\medskip 
  
  \label[adc_sec]
 \sec Čtení hodnot z~AD převodníku 
 
Měření  statorových proudů je nutné k plnému momentovému řízení nebo k řízení bez polohových senzorů (sensorless control). 

Plošném spoj výkonového stupně {\em 3P-MOTOR-DRIVER-1} proto obsahuje čtyřkanálový, 12-bitový A/D převodník ADS7841. Na vstup převodníku jsou připojeny senzory proudů protékajících jednotlivými fázemi, které využívají Hallova jevu. Převodník může pracovat buď ve 12-bitovém nebo jen v~8-bitovém režimu \cite[adc_man]. 

Důležité je zvolit správnou hodinovou frekvenci, která bude přivedena na hodinový vstup převodníku. Její maximální hodnota se pro daný typ převodníku liší podle velikosti napájecího napětí obvodu, viz sekce \ref[vyk_hw_sec]. Obvod je stejně, jako celé FPGA, napájen napětím 3.3V, které je přivedeno z~RPi. Hodinová frekvence tak byla stanovena na hodnotu 2.08Mhz. 

Tato frekvence je vytvořena kombinací frekvenčních děliček implementovaných v~komponentách "divider.vhdl" a "adc_reader.vhdl". V~komponentě "dvider.vhdl" dochází k~vydělení frekvence 50MHz dvanácti a vzniká tak frekvence o~velikosti 4.17MHz. Tato frekvence je následně vydělena dvěma v~komponentě "adc_reader.vhdl", o~které je více napsáno níže. Aby v~rámci komponenty "adc_reader" nedošlo k~vytvoření nové hodinové domény, je ke spouštění Procesu ve VHDL určen hlavní 50MHz hodinový signál. Tento signál pak pouze vzorkuje pomalejší 4.17Mhz hodiny. Podobné řešení je popsáno již v~sekci \ref[spi_slave_sec].

AD převodník je schopen pracovat v~několika módech, které se liší počtem hodinových cyklů nutných k~jednomu převodu. V~základním módu je třeba 24 hodinových pulzů na jednu konverzi. Tento mód předpokládá komunikaci se zařízením vyžadujícím přenos dat po SPI protokolu s~pevnou délku slova 8 bitů. Je určený především pro nepravidelné odečítání většinou z~mikrokontroléru. Pokud je třeba odečítat hodnoty pravidelně a co nejrychleji, je k~dispozici 16-pulzový převod.

Je-li možnost použít FPGA obvod, není nutné se omezovat 8-bitovou šířkou slova a je možné využít nejrychlejší variantu. Tedy konverzi dokončenou za 15 hodinových pulzů. V~použitém řešení byla zvolena právě tahle varinta. Průběh 15-cyklového převodu z~hlediska datového přenosu ukazuje Obrázek \ref[15clkconv_obr].


Komponenta "adc_reader", kromě frekvenční děličky, která je spíše vedlejším produktem, realizuje celou komunikaci mezi AD převodníkem a FPGA. Ta se skládá z~přenosu řídícího slova z~FPGA do ADC a z~následného vyčtení hodnot. Převodník je připojen pomocí čtyř vodičů, analogických k~vodičům použitých v~SPI komunikaci: "CS"(SE), "DCLK"(SCLK), "DIN"("MOSI") a "DOUT"("MISO").


Řídící slovo je tvořeno osmi bity. Prvním z~nich je startbit, který při delším provozu s~nepravidelným vyčítáním, při kterém není  vypnutý hodinový signál, definuje počátek komunikace. Následují tři bity adresy určené pro výběr jednoho ze čtyř kanálů. Další bity definují výběr buď 8 či 12-bitové konverze a volbu mezi  \uv{Single-Ended} nebo diferenčním zapojením. Poslední dva bity slouží k~nastavení úspornéro režimu v~době mezi konverzemi.  

\medskip \clabel[15clkconv_obr]{Průbeh konverze v~režimu 15 hodinových pulzůp na převod}
\picw=13cm \cinspic 15clkconv.png
\caption/f Průbeh konverze v~režimu 15 hodinových pulzůp na převod (Zdroj:Texas Instruments)
\medskip

Komponenta "adc_reader" pak implementuje komunikaci pomocí stavového automatu. Každý ze stavů generuje buď logickou úroveň 1 či 0 do signálu "DCLK". Pokud tak nastala při přechodu mezi dvěma stavy sestupná hrana,   je zapsán bit řídícího slova na vodič "DIN". Ve stejné chvíli také dochází k~zápisu hodnoty na vodič "DOUT" na straně ADC. Při nástupné hraně jsou naopak hodnoty na vodičích "DIN" a "DOUT" vzorkovány. Protože k~přechodu mezi dvěma stavy dochází vždy synchronně s~nástupnou hranou hodinového signálu, má signál "DCLK" vysílaný do převodníku práve poloviční frekvenci.

Nutnost přecházet mezi stavy však neexistuje jen u~konfigurace převodníku a vyčítání hodnot. Je třeba totiž přepínat i mezi jednotlivými kanály. Výše zmíněný stavový automat je tak logicky vnořen do dalšího, který přepíná právě mezi odečítáním proudů z~jednotlivých fází. 

Konfiguraci řídicího slova a adresy kanálů všech tří fází ukazují tabulky \ref[ctrl_word_tab] a \ref[address_tab].

 \medskip \clabel[ctrl_word_tab]{Konfigurace řídícího slova ADC}
\ctable{lcl}{ 
	\hfil Bit & Hodnota &Funkce  \crl
		7 (MSB) & 1 & Start bit \cr
		6 & Bit 2 adresy & Bit 2 adresy \cr
		5 & Bit 1 adresy & Bit 1 adresy \cr
		4 & Bit 0 adresy & Bit 0 adresy \cr		
		3 & 0 & 12-bitový převod \cr
		2 & 1 & Single-Ended zapojení \cr
		1 & 0 & Power Down mód \cr
		0 (LSB) & 0 & Power Down mód \cr
}
\caption/t Konfigurace řídícího slova ADC 
\medskip 

 \medskip \clabel[address_tab]{Adresace kanálů ADC}
\ctable{cccc}{ 
	\hfil Kanál & Bit 2 adresy & Bit 1 adresy & Bit 0 adresy  \crl
		ch0 & 0 & 0 & 1 \cr
		ch1 & 1 & 0 & 1 \cr
		ch2 & 0 & 1 & 0 \cr
}
\caption/t Adresace kanálů ADC 
\medskip 

\secc Sčítání více hodnot proudu

Po první implementaci měření proudů bylo patrné, že nedochází k~ustálení hodnot přibližně na posledních 5 bitech. Částečným zpřesněním může být použití výběrového průměru namísto jen jedné změřené hodnoty.

 K~vyčtení hodnoty z~AD převodníku dochází v porovnání s~frekvencí řídicí smyčky (1kHz) poměrně rychle. Při 15 hodinových cyklech nutných pro jednu konverzi a hodinové frekvenci 2.08Mhz, může dojít až ke 138 převodům. Pro každou měřenou fázi se jedná přibližně o 46 převodů. Byla provedena následující úvaha:

Změřenou hodnotu proudu procházejícího jednou z~fází za neměnných podmínek označme jako náhodnou veličinu $X$. Za předpokladu, že tato náhodná veličina má normální rozložení pravděpodobnosti, platí, že skutečná hodnota proudu je rovna její střední hodnotě. Tedy $i_p=EX$, $p\in\{a,b,c\}$.

Realizujme tedy náhodný výběr z~této veličiny a spočtěme jeho výběrový průměr. Pro výběrový průměr náhodné veličiny platí následující vztahy\cite[navara]:

Výběrový průměr z~náhodného výběru ${\bf{X}}=(X_1,...,X_n)$ je

$$\overline{\bf{X}}={{1}\over{n}}\sum\limits_{j=1}^n X_j \eqmark$$

Potom platí, že střední hodnota výběrového průměru se rovná střední hodnotě náhodné veličiny $X$.

$$ E\overline{\bf{X}}=EX \eqmark $$

Pro jeho směrodatnou odchylku $\sigma_{\overline{\bf{x}}_n}$ pak platí:

$$\sigma_{\overline{\bf{x}}_n}={{1}\over{\sqrt{n}}}\sigma_x \eqmark$$

Za předpokladu, že $n=46$ tedy platí, že $\sigma_{\overline{\bf{x}}_{46}}\approx{{1}\over{6.8}}\sigma_x$. Směrodatná odchylka výběrového průměru se oproti odečtení samostatných měření zmenšila 6.8x. A~protože $\log_2 6.8\approx2.7$, je možno říci, že jsme získali téměř tři bity informace navíc.

\sec Generování PWM

Generováním signálů PWM se zabývá komponenta "mcpwm". Její návrh implementuje 11-bitovou PWM.

 Základem funkce je nastavení příslušného výstupu na hodnotu logická 1 při průchodu čítače "count" nulou a ukončení plnění PWM cyklu při shodně čítače "count" se zadanou nodnotou plnění, uloženou v registru "match_reg". Hodnota "match" je odesílána ve finální podobě již z~Raspberry Pi. Čítač "count" je inkrementován hlavním hodinovým signálem "gpio_clk" o frekvenci 50MHz, frekvence PWM je tedy $50000/2^{11}\approx 24.4$kHz.

Průchod čítače "count" nulou je mimo jiné detekován nastavením signálu "sync" po dobu jednoho hodinového cyklu na hodnotu 1.
\ttline-1
\begtt
process (sync, count, match_reg, q)  
begin
  if count = match_reg then 
    next_q <= '0';
  elsif sync = '1' then 			
    next_q <= '1';
  else
    next_q <= q;
  end if;
end process;\endtt
  
   Jeden hodinový cyklus před nastavením signálu "sync" na hodnotu 1, je prováděna kontrola, zda je k~dispozici nová hodnota signálu "match". V~takovém případě je v~dalším cyklu PWM používána již aktualizovaná hodnota "match_reg<=match". 

Protože potřebujeme generovat tři signály PWM, je nutné bloky "mcpwm" vytvořit právě tři. Vystup čítače je pak rozveden na všechny tři bloky.  


\sec Dekódování IRC

Dekódování výstupů IRC senzoru je realizováno v~komponentě "qcounter.vhdl". 

Vstupem komponenty jsou signály "irc_A" a "irc_B". Podle pořadí, v~jakém dochází ke změnám těchto dvou signálů,je možné odvodit, v~jakém směru se motor otáčí.

Signály "irc_A" a "irc_B" jsou nejprve synchronně vzorkovány DFF obvodem spouštěným hlavní hodinovou frekvencí "gpio_clk". Aby došlo ke ztrátě informace o~poloze, muselo by tak dojít ke dvěma změnám jednoho signálu během jednoho hodinového cyklu. Motor by se tedy musel za tuto dobu pootočit o~tři rozlišitelné pozice IRC. To by při frekvenci "gpio_clk" 50MHz znamenalo frekvenci otáčení  nejméně 75KHz, tedy 4.5 miliónu otáček za minutu, což není z konstrukčních důvodů zdaleka možné.

Nejmenší dva bity výsledné pozice jsou vytořeny čistě kombinačně z~navzorkovaných "irc_A" a "irc_B":
  \ttline-1   
  \begtt
	qcount(0) <= a xor b;
	qcount(1) <= b;\endtt
 
Přechod do vyššího řádu je pak řešen pomocí 30-bitového čítače "count":
\begtt
	if (a_prev = '0') and (b_prev = '1') and (a = '0') and (b = '0') then 
		  count <= count_prev + 1;
	elsif (a_prev = '0') and (b_prev = '0') and (a = '0') and (b ='1') then 
		  count <= count_prev - 1;
	else
		  count <= count_prev;
	end if;\endtt
Veličiny s~příponou "_prev" jsou pak veličiny zpožděné o~jeden hodinový cyklus oproti těm bez přípony. Čítač je nakonec do výstupu komponenty promítnut následovně:
\begtt
  qcount(31 downto 2) <= count;\endtt

\vfil \break
\sec Implementace požadavků RT rozšíření v~uživatelském kódu 

Aby bylo možné plně využívat možností, které nabízí RT-rozšíření jádra Linux, je nutné v~uživatelském kódu dodržovat některá základní pravidla. K~těmto pravidlům patří například použití RT plánovací strategie nebo správné nastavení priorit vláken v~rámci plánovače \cite[rt-wiki]. Implementaci těchto požadavků se věnuje právě tato sekce.

\secc Nasatvení priority a plánovací strategie

Jádro OS Linux implementuje pět různých plánovacích strategií. Strategie "SCHED_FIFO", "SCHED_RR" a "SCHED_OTHER" jsou definovány standartem POSIX, "SCHED_BATCH" a "SCHED_IDLE" jsou pak pro systém specifické. Pro plánování každého vlákna aplikace může být zvolena libovolná z nich.

Strategie "SCHED_OTHER" přiděluje úlohám poměrnou část strojového času podle nastavení {\em nice}.

Pro RT aplikace jsou využívány strategie "SCHED_FIFO" a "SCHED_RR", které mají v okamžiku přeplánování přednost před všemi ostatními. Strategie "SCHED_FIFO" a "SCHED_RR" využívají plánování s~pevnými prioritami. Pokud je připraveno k~běhu vlákno s~vyšší prioritou, než má vlákno právě běžicí, je běžící vlákno v nebližší možné době nahrazeno vláknem z vyšší prioritou.

Omezou dobu odezvy, za kterou dojde k přeplánování, pak garantuje pouze jádro s aplikovaným RT rozšířením, tím že odstraňuje nepřerušitelné úseky kódu ve službách a servisních vláknch jádra OS.

Priority vláken v rámci strategií "SCHED_FIFO" a "SCHED_RR" je možné explicitně stanovit v~uživatelském kódu. Rozsah jejich hodnot se pohybuje mezi 99 a 1. Hodnota 50 je výchozí priorita úloh obsluhujících v RT variantě jádra přerušení od periférií. Platí, že čím vyšší hodnota, tím vyšší priorita. 

V~rámci prioritního plánování je ještě nutné stanovit, k~jakému chování dojde, budou-li k~běhu připravena dvě vlákna se stejnou prioritou. V tomto bodě se strategie "SCHED_FIFO" a "SCHED_RR" následovně odlišují: 


\begitems 

* "SCHED_FIFO":  V~případě, že právě beží jiné "SCHED_FIFO" nebo "SCHED_RR" vlákno se stejnou prioritou, je nové vlákno zařazeno na konec fronty úloh, se stejnou prioritou, čekajících na přidělení procesorového času. Ve chvíli, kdy je novému vláknu procesor přidělen, není mu odejmut, dokud není zablokováno, ukončeno nebo nahrazeno vláknem s vyšší prioritou. 

* "SCHED_RR": Sdílí všechny vlastnosti "SCHED_FIFO". Běžící vlákno je ale přeplánováno vždy po uplynutí pevně stanoveného časového kvanta. Respektive je zařazeno na konec fronty úloh, se stejnou prioritou, čekajících na přidělení procesorového času.
\enditems

Pro nastavení priority a plánovací strategie v~rámci vlákna slouží systémové volání: "int sched_setscheduler(pid_t pid, int p, const struct sched_param *s)". Jeho použití je následující:

\begtt
struct sched_param param;
param.sched_priority = PRIORITY;
if(sched_setscheduler(0, SCHED_FIFO, &param) == -1) {
     perror("sched_setscheduler failed");
     exit(-1);
}\endtt

Pro nastavení priority a plánovače vlákna, které teprve bude vytvořeno je nutné nejprve povolit nastavení plánovače prostřednicvím atributu, který je předáván při tvorbě vlákna (dále jen \uv{atribut}). Poté je třeba nastavit prioritu a plánovací strategii. Nakonec je vytvořeno i samotné vlákno. Celý proces je uveden níže: (Pro zvýšení přehlednosti zde byla odstraněna detekce chybových stavů)
\begtt
	pthread_attr_t attr; 	       /*atribut předávaný při tvorbě vlákna*/
	struct sched_param schparam;	/*struktura pro nastavení priority*/

	pthread_attr_init(&attr);    /*inicializace atributu*/
	
	/*povolení nastavení planovací strategie prostřednictvím atributu*/
	(pthread_attr_setinheritsched(&attr, PTHREAD_EXPLICIT_SCHED); 
	
	pthread_attr_setschedpolicy(&attr, SCHED_FIFO); /*nastaveni planovace*/ 
	
	schparam.sched_priority = PRIORITY;             /*nastaveni priority*/

	/*ulozeni priority podle hodnoty 'schparam' do atributu*/
	pthread_attr_setschedparam(&attr, &schparam); 
	
	pthread_create(thread, &attr, start_routine, arg); /*vytvori vlakno*/

	/*uvolneni struktury, nema vliv na vlakna jiz vytvorena*/
	pthread_attr_destroy(&attr); \endtt
	
\secc Řídicí smyčka

Frekvence řídicí smyčky byla stanovena v~sekci \ref[ctr_loop_freq]. Nyní je třeba zajistit, aby byla tato frekvence skutečně dodržena.

Pro periodického vykonávání kódu o~stanovené frekvenci je možné využít cyklu "while", v~jehož těle je volána funkce realizující čekání. Nejjednodušší variantou takové funkce jsou knihovní volání "unsigned int sleep(unsigned int seconds)" a "int usleep(useconds_t usec)". Tato volání však neberou v~úvahu čas, po který je vykonávána samotná periodická činnost. Prodleva, která je takto realizovaná se také může prodlužovat v~závislossti na zatížení systému nebo na délce vykonávání samotného volání \cite[usleep_man].

Je tedy nutné použít \uv{čekací} funkci s~přesně definovaným chováním. Takovou funkcí je "int clock_nanosleep(...)". Při jejím volání, na místo čekání po stanovenou dobu, dojde k~pozastavení vykonávání kódu do časového okamžiku, definovaného ve struktuře "timespec". Na počátku je tedy nutné získat aktuální čas, k~tomu slouží funkce  "int clock_gettime(clockid_t clk_id, struct timespec *tp)". Její použití je následující:

\ttline 0
\begtt      
struct timespec t_spec;
clock_gettime(CLOCK_MONOTONIC ,&t_spec); /*zjisteni pocatecniho casu*/ \endtt

"CLOCK_MONOTONIC" označuje použití systémových hodin, které pracují podobně jako "CLOCK_REALTIME" nezávisle na zatížení systému. Hodnotu "CLOCK_MONOTONIC" navíc není možné za běhu modifikovat například administrátorským zásahem.

Pokud je to nutné, je poté možné inkrementovat "timespec" a nastavit tak okamžik opětovného spuštění kódu. Tato možnost může být využita například při ladění.

\begtt
t_spec.tv_sec++; /*pocatecni prodleva - 1s*/ \endtt

Nyní je již možné spustit samotnou smyčku. Při každém jejím průchodu je hodnota uložená ve struktuře "timespec" zvětšena o~hodnotu rovnou periodě řídicí smyčky. V~totmto připadě "1000*1000 ns".

\begtt
while(1) {
    /* čekání na stanovený časový okamžik */
    clock_nanosleep(CLOCK_MONOTONIC, TIMER_ABSTIME, &t_spec, NULL);

    /* vlasntni kod ridici smycky */

    t_spec.tv_nsec += PERIODA_NS; /*nastavení nového spouštěcího času*/ \endtt
    
Aby nedošlo k~přetečení počtu nanosekund ve struktuře "timespec", je nutné průběžně přepočítávat nanosekundy na sekundy.

\begtt
    while (t_spec.tv_nsec >= NSEC_PER_SEC) {
        t_spec.tv_nsec -= NSEC_PER_SEC;
        t_spec.tv_sec++;
}   }\endtt

\secc Uzamčení aplikace v~RAM

Při vyšším zatížení systému může docházet k~odkládání a výměně procesů (Swapping) mezi hlavní (RAM) a sekundární pamětí počítače. 

Odložení procesu aplikace, vede ke zvýšení reakčních časů na vnější události. U~magnetických disků může tímto způsobem narůstat zpoždění o~až několik milisekund.\cite[iops] Z~tohoto důvodu je nutné, aby proces řídicí aplikace zůstal uzamčen v~primární paměti. K~tomuto účelu je využíváno systémové volání "int mlockall(int flags)", které zajistí uzamčení stránek v~hlavní paměti.

Parametr "int flags" definuje, zda budou v~hlavní paměti uzamčeny jen aktuálně namapované stránky (makro "MCL_CURRENT") nebo stránky namapované později (makro "MCL_FUTURE"). Tato makra je možno použít současně. Příklad použití je uveden níže:

\ttline-1
\begtt
if(mlockall(MCL_CURRENT|MCL_FUTURE) == -1) {
    perror("mlockall failed");
    exit(-2);
}\endtt

Takto použité volání zajistí, že nedojde v~výpadku žádné stránky, která byla nebo bude namapováva do primární paměti počítače.
 
\sec Elektronická komutace

Jak bylo uvedeno výše, PMS motory nevyužívají ke komutaci mechanické kartáče, Komutace je zde řízena elektronicky. Komutaci je možné provádět několika způsoby v~závislosti na informacích o~stavu motoru, které máme k~dispozici. Popisem těchto variant se zabývá právě tato sekce.

\label[hall_only_sec]
\secc Komutace s~využitím pouze Hallových sond

Pokud není k~dispozici absolutní poloha motoru, není možné řídit komutaci pomocí výstupu z~IRC senzoru. V~takovém připadě je realizován nejjednodušší způsob komutace, pouze za použití výstupu z~Hallových sond.

Výstup z~Hallových sond umožňuje lokalizovat polohu motor ve dvanáctí úsecích mechanického cyklu. Vzhledem ke konstrukci motoru odpovídají jednomu mechanickému cyklu dva cykly elektrické. Je tedy možné určit polohu motoru v~rámci jednoho ze šesti úseků elektrického cyklu. Rozložení úseků elektrického cyklu je na obrázku \ref[hall_pos_obr].

Z~takto zjištěné polohy je následně možné řídit komutaci tak, aby bylo napětí přivedeno jen na jednou z~fází a docházelo tak k~natočení rotoru do požadované pozice. 
 
\medskip \clabel[hall_pos_obr]{Rozložení výstupů z~Hallových sond}
\picw=9cm \cinspic hall_pos.pdf
\caption/f Rozložení výstupů z~Hallových sond v~elktrickém cyklu (trojice bitů uprostřed [Hall1 Hall2 Hall3]). Závorkované hodnoty při vnějším okraji jsou přibližné vzdálenosti od indexu vypočténé pomocí IRC.
\medskip 

V~obrázku \ref[hall_pos_obr] jsou pomocí šipek na barevných soustředných kružnicích vyznačeny dva směry pohybu rotoru. Pro každý ze směrů různě vybarvéné úseky dané kružnice značí, jaká fáze musí být při daném natočení napájena, aby došlo k~pohybu žádaným směrem. Barevnými čísly u~šipek směřujících od středu kružnic jsou pak označeny pozice, ve kterých dojde k~ustálení motoru při napájení pouze dané fáze.

Pokud je vyžadován pohyb ve směru hodinových ručiček, bude kód komutátoru následující:

\begtt		
if (hal2 && !hal3){
    rps.pwm1=0;
    rps.pwm2=0;
    rps.pwm3=duty;
}else if (hal1 && !hal2){
    rps.pwm1=duty;
    rps.pwm2=0;
    rps.pwm3=0;
}else if (!hal1 && hal3){
    rps.pwm1=0;
    rps.pwm2=duty;
    rps.pwm3=0;
} \endtt

Velkou nevýhodou této komutace je kolísání točivého momentu v~závislosti na úhlu natočení rotoru. Dochází tak k~nepříjemným otřesům motoru.

\label[120_sec]
\secc Komutace pomocí přičítání 120 stupňů

Pokud je k~dispozici absolutní poloha rotoru v~rámci celého elektrického cyklu s~dostatečnou přesností, je možné právádět komutaci tak, aby točivý moment zůstával konstantní v~průběhu celé otáčky.

Jednou z~možností, jak realizovat takovou komutaci je simulovat sinusový průběh napětí na jednotlivých fázích. Fáze přitom budou oproti sobě posunuty o~$120^{\circ}$. Pro pohyb ve směru hodinových ručiček může být ve zdrojovém kódu taková operace provedena následovně:

\begtt
sin = pxmc_sin_fixed_inline(pos+DEGREE_240,10);
pwm1=sin*duty/1024;
if (pwm1<0) pwm1=0;

sin = pxmc_sin_fixed_inline(pos+DEGREE_120,10); 
pwm2=sin*duty/1024;
if (pwm2<0) pwm2=0;

sin = pxmc_sin_fixed_inline(pos,10);
pwm3=sin*duty/1024;
if (pwm3<0) pwm3=0;
\endtt

Kde "pxmc_sin_fixed_inline" je funkce z~knihovny {\em PXMC}, která celočíselně, se specifikovanou přesností 10 bitů, počítá hodnotu sinu. Proměnná "pos" udává úhlovou pozici rotoru. 

\label[vektor_impl_sec]
\secc Vektorové řízení

Vektorový řízení využívá pro výpočet proudu jednotlivými fázemi Clarkovu a Parkovu inverezní transformaci. S~jejich pomocí je možné řídit směr pohybu rotoru pouze řízením složky proudu rovnoběžné s~osou {\em q} v~{\em dq0} souřadném systému. Tato metoda je popsána v~sekci \ref[rizeni_sec]. 

Implementace vektorového řízení ve zdrojovém kódu zahrnuje především vytvoření funkcí pro obě inverzní transformace.

Úhel natočení rotoru je inkrementován při pohybu po směru hodinových ručiček, algoritmus pro výpočet inverzní Parkovy transformace proto vychází z~rovnice \ref[inv_clark_rce_2]:
\begtt
void dq2alphabeta(int32_t *alpha, int32_t *beta,
                  int d, int q,
                  int32_t sin, int32_t cos){
    *alpha=cos*d+sin*q;
    *beta=-sin*d+cos*q;
}
\endtt

Clarkova inverzní transformace je zde vytvořena pomocí \ref[inv_clark_num_rce], její kód je následující:
\begtt
void alphabeta2pwm3(int32_t * ia, int32_t * ib, int32_t *ic,
                    int32_t alpha, int32_t beta){
    *ia=alpha;
    *ib=-alpha/2+beta*887/1024;
    *ic=-alpha/2-beta*887/1024;
}
\endtt

Pro výpočet hodnot $\sin{\vartheta}$ a $\cos{\vartheta}$ je zde použita funkce z~knihovny {\em PXMC}, "void" "pxmc_sincos_fixed_inline(int32_t *sn, int32_t *cs, uint32_t x, int bit)". Jejím parametrem je, kromě počtu bitů vysledku, úhel $\vartheta$ (parametr "x"). Pro potřeby funkce je tak výstup IRC senzoru, který udává natočení motoru, převeden na cyklickou "uint32_t" logiku. Plný úhel $2\pi$ rad je zde ekvivalentní hodnotě $2^{32}$.

Transformace napětí při delta zapojení vychází z rovnic \ref[u1_rce] až \ref[u3_rce]. Parametr $t$ je zde volen tak, aby nejmenší z napětí $u_1$ až $u_3$ bylo rovno nule. Její kód je následující:
\begtt
void transDelta(int32_t * u1, int32_t * u2, int32_t *u3,
                int32_t ub , int32_t uc){
    int32_t t;

    /*vypocte napeti tak, aby odpovidaly rozdily*/
    *u1=uc;
    *u2=uc+ub;
    *u3=0;
    
    /*najde zaporne napeti*/
    t=min(*u1,*u2,*u3);
    
    /*dorovna zaporna napeti na nulu*/
    *u1-=t;
    *u2-=t;
    *u3-=t;
}
\endtt
Všechny tři kroky jsou provedeny takto:
\ttline 0
\begtt
{
    uint32_t pos;
    int32_t sin, cos;
    int32_t alpha, beta;
    int32_t ua,ub,uc;
    int32_t ia,ib,ic;
    int32_t u1,u2,u3;
    pos=rps.index_dist;

    pos+=960; /*zarovnani faze 'a' s osou 'alpha'*/

    /*pro výpočet sin a cos je pouzita 32-bit cyklicka logika*/
    pos*=4294967;
    pxmc_sincos_fixed_inline(&sin, &cos, pos, 16);

    dq2alphabeta(&alpha, &beta,0,duty, sin, cos);
    alpha>>=16;
    beta>>=16;

    alphabeta2pwm3(&ia,&ib, &ic,alpha,beta);
\endtt
Na tomto místě by mělo být implementováno zpětnovazební řízení jednotlivých proudů za použití jejich naměřených hodnot. Pro jednoduchost je ale použita jen dopřednovazební regulace vycházející z rovnic \ref[rce1] až \ref[clark_napet_rce_3]:
\begtt
    ua=ia;
    ub=ib;
    uc=ic;
\endtt
Nyní zbývá přepočítat fázová napětí a podle jejich hodnot nastavit šířky plnění PWM:
\begtt
    transDelta(&u1,&u2, &u3,ub,uc);

    rps.pwm1=(uint16_t)u1;
    rps.pwm2=(uint16_t)u2;
    rps.pwm3=(uint16_t)u3;
}\endtt

	
 \chap Závěr
 
 \sec Záznamy průběhů PXMC
 
 
  S využitím knihovny PXMC byly zachyceny některé průběhy statorových proudů a napětí. Průběh při nastavení pevné šírky plnění příkazem "PWMA:1000" je na obrázku \ref[prubehy_pwma1_obr].

\medskip \clabel[prubehy_pwma1_obr]{Záznam průběhu při konfiguraci PWMA:1000}
\picw=17cm \cinspic pwma1000_detail.png
\caption/f Záznam průběhu při konfiguraci PWMA:1000 bez zatížení. Na svislé ose je vynesena pozice IRC, v grafu je vyznačena žlutozelenou barvou. 
\medskip 
  
Detail průběhů napětí a proudů z obrázku \ref[prubehy_pwma1_obr] je na obrázku \ref[prubehy_pwma2_obr].
 Z tohoto obrázku je také patrné, že první kanál ADC má o něco menší zesílení. Následná unalýza ukázala jako pravděpodobné, že dochází k nežádoucímu magnetickému rušení.
 
 Senzory obsahují pro měření proudu jen necelý jeden závit zařazený mezi výkonovými piny. Obvody sice jsou odstíněné podle manuálu proti elektrostatickému rušení, ale ne proti magnetismu. Zde nastává problém, že proudy dalších dvou výkonových výstupů prochází v blízkosti obvodu příslušného měřené fázi . Magnetické pole kolem \uv{přímého} vodiče se tak značně promítá do blízkého obvodu. Přitom podle geometrie jednotlivých vodičů je ovlivnění různé. 
 
 Aby byly takto naměřené hodnoty použitelné pro regulaci, bylo by nutné provést analýzu metody kalibrace, která by eliminovala vzájemné ovlivnění. Přitom vzhledem k tomu, že soustava tří proudů je přeurčená, viz rovnice \ref[soucet_nula_rce], postačují pouze dvě přesně měřené hodnoty. Třetí hodnotu, byť změřenou nepřesně, je možné za jistých předpokladů, použít ke zpřesnění výpočtu. 
  
\medskip \clabel[prubehy_pwma2_obr]{Záznam průběhu při konfiguraci PWMA:1000. Detail.}
\picw=17cm \cinspic pwma1000_detail2.png
\caption/f Záznam průběhu při konfiguraci PWMA:1000 bez zatížení. Tečkované hodnoty jsou šířky plnění PWM. Slabší, modré, červené a zelené průběhy jsou naměřené proudy. 
\medskip 
 
 Na obrázku \ref[prubehy_1] je zachycen průběh při řízení rychlosti. Byl použit příkaz "SPDA:1000". Do hodnoty 1500 na vodorovné, časové ose je motor nezatížen. Dále od této hodnoty pak dochází k postupnému narůstání zátěže.
  
 \medskip \clabel[prubehy_1]{Záznam průběhu při konfiguraci SPDA:1000}
\picw=17cm \cinspic spda1000_detail.png
\caption/f Záznam průběhu při konfiguraci SPDA:1000 a následném zatížení
\medskip 
 

\sec Závěrečné hodnocení
 
Cílem  práce  je  realizovat řízení pro  synchronní bezkartáčové motory s~využitím jednodeskového počítače Raspberry Pi a Linuxu. To vše při použití rozšiřující jednotky intergrující výkonový hardware a FPGA obvod.
  
  V~první  části  práce  jsou  prezentovány  základy  vlastní konstrukce synchronního  bezkartáčového motoru,  princip  jeho  činnosti  a základní matematický popis. Jako vhodné matematické  nástroje jsou zde uvedeny Clarkova a Parkova transformace.
  
  Další kapitola podrobně popisuje použitý hadrware. Je zde věnován prostor motoru a jeho parametrům, rozšiřující jednotce nebo RPi a jeho vlastnostem. Zvláštní pozornost se dostala nasazení víceúčelového operačního systému GNU/Linux, a jeho RT-rozšíření, pro realizaci zpětvovazebního řízení. Bylo tak potvrzeno, že tento systém je použitelný a vhodný pro zadanou práci a je tak možné ho doporučit k~podobným účelům. 
  
  Následující kapitola se již plně věnuje realizaci projektu. V~úvodu je uvedeno, jaké požadavky klade řízený motor na frekvenci řídicí smyčky. S~ohledem na možnosti procesorové jednotky a vlastnosti řízené soustavy je vybrána fekvence 1kHz. Realizace projektu prokázála, že řízení za této frekvence je možné. 
  
  Jako minimální objem dat přenášených mezi RPi a rozšiřující jednotkou v~každém cyklu řídicí smyčky bylo stanoveno 128 bitů. Pro jejich přenos byl vybrán protokol SPI. Pro budoucí práci je možné doporučit využití právě tohotu protokolu. Zajímavou alternativou je ale použití protokolu SSI, který v~sobě integruje přenos hodinového signálu.
  
  Pro možnou realizaci plného momentového řízení a řízení bez polohových senzorů (sensorless control) je nezbyná znalost proudů, protékajících vinutím statoru. Jejich snímaní je prováděno s~využitím Hallova jevu. Napětí, takto získané je převáděno 12-bitovým AD převodníkem. Zde bylo provedeno zpřesnění snímání tohoto napětí. Nyní je místo jedné odečtené hodnoty posílán řídicí jednotce jejich výběrový průměr. Toto řešeni vedlo k~redukci šumu a tím krozšíření přesnosti naměřených hodnot.
  
  Vlastní sekce je věnována implementaci požadavků a algoritmickým konstrukcím, které musejí být dodrženy v řídicí aplikaci využívající RT-rozšíření jádra Linux. Lze konstatovat, že bez jejich naplnění nelze uživatelské aplikaci garantovat deterministické chování. Samotná aplikace RT-rozšíření tak způsobí pouze prodloužení průměrného času odezvy na vnější událost, aniž by přinášela jakékoli výhody.
  
  Pro výukové účely jsou implementovány dvě jednoduché metody elektronické komutace. Při použití komutace využívající jen výstup z~Hallových sond dochází k~nežádoucím vibracím motoru. Jedná se ale o~jedinou možnost, pokud nemáme k~dispozici přesnou hodnotu natočení rotoru v~rámci celého rozsahu otáčeni nebo dostatečně přesné měření proudu.
  
   S~přesnou znalostí polohy je možné provádět komutaci založenou na fázovém posunu všech fází o $120^\circ$ a realizovat tak jednoduché napěťové řízení.
  
   
 

 \bibchap
 \usebib/c (simple) mybase

\app DVD

 \sec pokyny
 
Na platformě procesorové desky Raspberry Pi implementujte systém pro řízení bezkartáčových (BLDC/PMSM) motorů.

1. Pro komunikaci procesorového systému s~výkonovým hardwarem realizovaným s~využitím programovatelného obvodu (FPGA) vyberte vhodný protokol a periferii.

2. Pro vybraný způsob komunikace navrhněte ovladač na straně jádra Linux a obvodový návrh ve VHDL na straně FPGA.

3. Integrujte bloky pro snímání polohy, řízení výkonových stupňů a měření proudu do FPGA návrhu.

4. S~využitím navržených periferií realizujte řízení bezkartáčového motoru.

5. Vyžaduje se podrobná technická dokumentace včetně přípravy podkladů pro prezentaci včetně videozáznamu.

\app Zkratky\par \makeglos %vlozi novou prilohu

\label[priloha_motor]
\app Dokumentace výkonového stupně Rpi-Mi-1, PiKRON 2014


\topinsert 
\picw=16cm \cinspic 3p-motor-driver-1-sch.pdf
\caption/f Schéma driveru motoru
\endinsert 

\topinsert 
\picw=15.8cm \cinspic rpi-mi-1-sch.pdf
\caption/f Schéma propojení RPi a FPGA obvodu
\endinsert  
 
 \bye
  
 